/*
** ゲームグラフィックス特論用補助プログラム GLFW 版
**

Copyright (c) 2011, 2012, 2013 Kohe Tokoi. All Rights Reserved.

Permission is hereby granted, free of charge,  to any person obtaining a copy 
of this software and associated documentation files (the "Software"), to deal 
in the Software without restriction,  including without limitation the rights 
to use, copy,  modify, merge,  publish, distribute,  sublicense,  and/or sell 
copies or substantial portions of the Software.

The above  copyright notice  and this permission notice  shall be included in 
all copies or substantial portions of the Software.

THE SOFTWARE  IS PROVIDED "AS IS",  WITHOUT WARRANTY OF ANY KIND,  EXPRESS OR 
IMPLIED,  INCLUDING  BUT  NOT LIMITED  TO THE WARRANTIES  OF MERCHANTABILITY, 
FITNESS  FOR  A PARTICULAR PURPOSE  AND NONINFRINGEMENT.  IN  NO EVENT  SHALL 
KOHE TOKOI  BE LIABLE FOR ANY CLAIM,  DAMAGES OR OTHER LIABILITY,  WHETHER IN 
AN ACTION  OF CONTRACT,  TORT  OR  OTHERWISE,  ARISING  FROM,  OUT OF  OR  IN 
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

**
*/

#include <cstdlib>
#include <cfloat>
#include <cmath>
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <map>

#if defined(_WIN32)
#  include <windows.h>
#endif

#include "gg.h"

#if defined(_WIN32)
PFNGLBLENDCOLORPROC glBlendColor;
PFNGLBLENDEQUATIONPROC glBlendEquation;
PFNGLDRAWRANGEELEMENTSPROC glDrawRangeElements;
PFNGLTEXIMAGE3DPROC glTexImage3D;
PFNGLTEXSUBIMAGE3DPROC glTexSubImage3D;
PFNGLCOPYTEXSUBIMAGE3DPROC glCopyTexSubImage3D;
PFNGLCOLORTABLEPROC glColorTable;
PFNGLCOLORTABLEPARAMETERFVPROC glColorTableParameterfv;
PFNGLCOLORTABLEPARAMETERIVPROC glColorTableParameteriv;
PFNGLCOPYCOLORTABLEPROC glCopyColorTable;
PFNGLGETCOLORTABLEPROC glGetColorTable;
PFNGLGETCOLORTABLEPARAMETERFVPROC glGetColorTableParameterfv;
PFNGLGETCOLORTABLEPARAMETERIVPROC glGetColorTableParameteriv;
PFNGLCOLORSUBTABLEPROC glColorSubTable;
PFNGLCOPYCOLORSUBTABLEPROC glCopyColorSubTable;
PFNGLCONVOLUTIONFILTER1DPROC glConvolutionFilter1D;
PFNGLCONVOLUTIONFILTER2DPROC glConvolutionFilter2D;
PFNGLCONVOLUTIONPARAMETERFPROC glConvolutionParameterf;
PFNGLCONVOLUTIONPARAMETERFVPROC glConvolutionParameterfv;
PFNGLCONVOLUTIONPARAMETERIPROC glConvolutionParameteri;
PFNGLCONVOLUTIONPARAMETERIVPROC glConvolutionParameteriv;
PFNGLCOPYCONVOLUTIONFILTER1DPROC glCopyConvolutionFilter1D;
PFNGLCOPYCONVOLUTIONFILTER2DPROC glCopyConvolutionFilter2D;
PFNGLGETCONVOLUTIONFILTERPROC glGetConvolutionFilter;
PFNGLGETCONVOLUTIONPARAMETERFVPROC glGetConvolutionParameterfv;
PFNGLGETCONVOLUTIONPARAMETERIVPROC glGetConvolutionParameteriv;
PFNGLGETSEPARABLEFILTERPROC glGetSeparableFilter;
PFNGLSEPARABLEFILTER2DPROC glSeparableFilter2D;
PFNGLGETHISTOGRAMPROC glGetHistogram;
PFNGLGETHISTOGRAMPARAMETERFVPROC glGetHistogramParameterfv;
PFNGLGETHISTOGRAMPARAMETERIVPROC glGetHistogramParameteriv;
PFNGLGETMINMAXPROC glGetMinmax;
PFNGLGETMINMAXPARAMETERFVPROC glGetMinmaxParameterfv;
PFNGLGETMINMAXPARAMETERIVPROC glGetMinmaxParameteriv;
PFNGLHISTOGRAMPROC glHistogram;
PFNGLMINMAXPROC glMinmax;
PFNGLRESETHISTOGRAMPROC glResetHistogram;
PFNGLRESETMINMAXPROC glResetMinmax;
PFNGLACTIVETEXTUREPROC glActiveTexture;
PFNGLSAMPLECOVERAGEPROC glSampleCoverage;
PFNGLCOMPRESSEDTEXIMAGE3DPROC glCompressedTexImage3D;
PFNGLCOMPRESSEDTEXIMAGE2DPROC glCompressedTexImage2D;
PFNGLCOMPRESSEDTEXIMAGE1DPROC glCompressedTexImage1D;
PFNGLCOMPRESSEDTEXSUBIMAGE3DPROC glCompressedTexSubImage3D;
PFNGLCOMPRESSEDTEXSUBIMAGE2DPROC glCompressedTexSubImage2D;
PFNGLCOMPRESSEDTEXSUBIMAGE1DPROC glCompressedTexSubImage1D;
PFNGLGETCOMPRESSEDTEXIMAGEPROC glGetCompressedTexImage;
PFNGLCLIENTACTIVETEXTUREPROC glClientActiveTexture;
PFNGLMULTITEXCOORD1DPROC glMultiTexCoord1d;
PFNGLMULTITEXCOORD1DVPROC glMultiTexCoord1dv;
PFNGLMULTITEXCOORD1FPROC glMultiTexCoord1f;
PFNGLMULTITEXCOORD1FVPROC glMultiTexCoord1fv;
PFNGLMULTITEXCOORD1IPROC glMultiTexCoord1i;
PFNGLMULTITEXCOORD1IVPROC glMultiTexCoord1iv;
PFNGLMULTITEXCOORD1SPROC glMultiTexCoord1s;
PFNGLMULTITEXCOORD1SVPROC glMultiTexCoord1sv;
PFNGLMULTITEXCOORD2DPROC glMultiTexCoord2d;
PFNGLMULTITEXCOORD2DVPROC glMultiTexCoord2dv;
PFNGLMULTITEXCOORD2FPROC glMultiTexCoord2f;
PFNGLMULTITEXCOORD2FVPROC glMultiTexCoord2fv;
PFNGLMULTITEXCOORD2IPROC glMultiTexCoord2i;
PFNGLMULTITEXCOORD2IVPROC glMultiTexCoord2iv;
PFNGLMULTITEXCOORD2SPROC glMultiTexCoord2s;
PFNGLMULTITEXCOORD2SVPROC glMultiTexCoord2sv;
PFNGLMULTITEXCOORD3DPROC glMultiTexCoord3d;
PFNGLMULTITEXCOORD3DVPROC glMultiTexCoord3dv;
PFNGLMULTITEXCOORD3FPROC glMultiTexCoord3f;
PFNGLMULTITEXCOORD3FVPROC glMultiTexCoord3fv;
PFNGLMULTITEXCOORD3IPROC glMultiTexCoord3i;
PFNGLMULTITEXCOORD3IVPROC glMultiTexCoord3iv;
PFNGLMULTITEXCOORD3SPROC glMultiTexCoord3s;
PFNGLMULTITEXCOORD3SVPROC glMultiTexCoord3sv;
PFNGLMULTITEXCOORD4DPROC glMultiTexCoord4d;
PFNGLMULTITEXCOORD4DVPROC glMultiTexCoord4dv;
PFNGLMULTITEXCOORD4FPROC glMultiTexCoord4f;
PFNGLMULTITEXCOORD4FVPROC glMultiTexCoord4fv;
PFNGLMULTITEXCOORD4IPROC glMultiTexCoord4i;
PFNGLMULTITEXCOORD4IVPROC glMultiTexCoord4iv;
PFNGLMULTITEXCOORD4SPROC glMultiTexCoord4s;
PFNGLMULTITEXCOORD4SVPROC glMultiTexCoord4sv;
PFNGLLOADTRANSPOSEMATRIXFPROC glLoadTransposeMatrixf;
PFNGLLOADTRANSPOSEMATRIXDPROC glLoadTransposeMatrixd;
PFNGLMULTTRANSPOSEMATRIXFPROC glMultTransposeMatrixf;
PFNGLMULTTRANSPOSEMATRIXDPROC glMultTransposeMatrixd;
PFNGLBLENDFUNCSEPARATEPROC glBlendFuncSeparate;
PFNGLMULTIDRAWARRAYSPROC glMultiDrawArrays;
PFNGLMULTIDRAWELEMENTSPROC glMultiDrawElements;
PFNGLPOINTPARAMETERFPROC glPointParameterf;
PFNGLPOINTPARAMETERFVPROC glPointParameterfv;
PFNGLPOINTPARAMETERIPROC glPointParameteri;
PFNGLPOINTPARAMETERIVPROC glPointParameteriv;
PFNGLFOGCOORDFPROC glFogCoordf;
PFNGLFOGCOORDFVPROC glFogCoordfv;
PFNGLFOGCOORDDPROC glFogCoordd;
PFNGLFOGCOORDDVPROC glFogCoorddv;
PFNGLFOGCOORDPOINTERPROC glFogCoordPointer;
PFNGLSECONDARYCOLOR3BPROC glSecondaryColor3b;
PFNGLSECONDARYCOLOR3BVPROC glSecondaryColor3bv;
PFNGLSECONDARYCOLOR3DPROC glSecondaryColor3d;
PFNGLSECONDARYCOLOR3DVPROC glSecondaryColor3dv;
PFNGLSECONDARYCOLOR3FPROC glSecondaryColor3f;
PFNGLSECONDARYCOLOR3FVPROC glSecondaryColor3fv;
PFNGLSECONDARYCOLOR3IPROC glSecondaryColor3i;
PFNGLSECONDARYCOLOR3IVPROC glSecondaryColor3iv;
PFNGLSECONDARYCOLOR3SPROC glSecondaryColor3s;
PFNGLSECONDARYCOLOR3SVPROC glSecondaryColor3sv;
PFNGLSECONDARYCOLOR3UBPROC glSecondaryColor3ub;
PFNGLSECONDARYCOLOR3UBVPROC glSecondaryColor3ubv;
PFNGLSECONDARYCOLOR3UIPROC glSecondaryColor3ui;
PFNGLSECONDARYCOLOR3UIVPROC glSecondaryColor3uiv;
PFNGLSECONDARYCOLOR3USPROC glSecondaryColor3us;
PFNGLSECONDARYCOLOR3USVPROC glSecondaryColor3usv;
PFNGLSECONDARYCOLORPOINTERPROC glSecondaryColorPointer;
PFNGLWINDOWPOS2DPROC glWindowPos2d;
PFNGLWINDOWPOS2DVPROC glWindowPos2dv;
PFNGLWINDOWPOS2FPROC glWindowPos2f;
PFNGLWINDOWPOS2FVPROC glWindowPos2fv;
PFNGLWINDOWPOS2IPROC glWindowPos2i;
PFNGLWINDOWPOS2IVPROC glWindowPos2iv;
PFNGLWINDOWPOS2SPROC glWindowPos2s;
PFNGLWINDOWPOS2SVPROC glWindowPos2sv;
PFNGLWINDOWPOS3DPROC glWindowPos3d;
PFNGLWINDOWPOS3DVPROC glWindowPos3dv;
PFNGLWINDOWPOS3FPROC glWindowPos3f;
PFNGLWINDOWPOS3FVPROC glWindowPos3fv;
PFNGLWINDOWPOS3IPROC glWindowPos3i;
PFNGLWINDOWPOS3IVPROC glWindowPos3iv;
PFNGLWINDOWPOS3SPROC glWindowPos3s;
PFNGLWINDOWPOS3SVPROC glWindowPos3sv;
PFNGLGENQUERIESPROC glGenQueries;
PFNGLDELETEQUERIESPROC glDeleteQueries;
PFNGLISQUERYPROC glIsQuery;
PFNGLBEGINQUERYPROC glBeginQuery;
PFNGLENDQUERYPROC glEndQuery;
PFNGLGETQUERYIVPROC glGetQueryiv;
PFNGLGETQUERYOBJECTIVPROC glGetQueryObjectiv;
PFNGLGETQUERYOBJECTUIVPROC glGetQueryObjectuiv;
PFNGLBINDBUFFERPROC glBindBuffer;
PFNGLDELETEBUFFERSPROC glDeleteBuffers;
PFNGLGENBUFFERSPROC glGenBuffers;
PFNGLISBUFFERPROC glIsBuffer;
PFNGLBUFFERDATAPROC glBufferData;
PFNGLBUFFERSUBDATAPROC glBufferSubData;
PFNGLGETBUFFERSUBDATAPROC glGetBufferSubData;
PFNGLMAPBUFFERPROC glMapBuffer;
PFNGLUNMAPBUFFERPROC glUnmapBuffer;
PFNGLGETBUFFERPARAMETERIVPROC glGetBufferParameteriv;
PFNGLGETBUFFERPOINTERVPROC glGetBufferPointerv;
PFNGLBLENDEQUATIONSEPARATEPROC glBlendEquationSeparate;
PFNGLDRAWBUFFERSPROC glDrawBuffers;
PFNGLSTENCILOPSEPARATEPROC glStencilOpSeparate;
PFNGLSTENCILFUNCSEPARATEPROC glStencilFuncSeparate;
PFNGLSTENCILMASKSEPARATEPROC glStencilMaskSeparate;
PFNGLATTACHSHADERPROC glAttachShader;
PFNGLBINDATTRIBLOCATIONPROC glBindAttribLocation;
PFNGLCOMPILESHADERPROC glCompileShader;
PFNGLCREATEPROGRAMPROC glCreateProgram;
PFNGLCREATESHADERPROC glCreateShader;
PFNGLDELETEPROGRAMPROC glDeleteProgram;
PFNGLDELETESHADERPROC glDeleteShader;
PFNGLDETACHSHADERPROC glDetachShader;
PFNGLDISABLEVERTEXATTRIBARRAYPROC glDisableVertexAttribArray;
PFNGLENABLEVERTEXATTRIBARRAYPROC glEnableVertexAttribArray;
PFNGLGETACTIVEATTRIBPROC glGetActiveAttrib;
PFNGLGETACTIVEUNIFORMPROC glGetActiveUniform;
PFNGLGETATTACHEDSHADERSPROC glGetAttachedShaders;
PFNGLGETATTRIBLOCATIONPROC glGetAttribLocation;
PFNGLGETPROGRAMIVPROC glGetProgramiv;
PFNGLGETPROGRAMINFOLOGPROC glGetProgramInfoLog;
PFNGLGETSHADERIVPROC glGetShaderiv;
PFNGLGETSHADERINFOLOGPROC glGetShaderInfoLog;
PFNGLGETSHADERSOURCEPROC glGetShaderSource;
PFNGLGETUNIFORMLOCATIONPROC glGetUniformLocation;
PFNGLGETUNIFORMFVPROC glGetUniformfv;
PFNGLGETUNIFORMIVPROC glGetUniformiv;
PFNGLGETVERTEXATTRIBDVPROC glGetVertexAttribdv;
PFNGLGETVERTEXATTRIBFVPROC glGetVertexAttribfv;
PFNGLGETVERTEXATTRIBIVPROC glGetVertexAttribiv;
PFNGLGETVERTEXATTRIBPOINTERVPROC glGetVertexAttribPointerv;
PFNGLISPROGRAMPROC glIsProgram;
PFNGLISSHADERPROC glIsShader;
PFNGLLINKPROGRAMPROC glLinkProgram;
PFNGLSHADERSOURCEPROC glShaderSource;
PFNGLUSEPROGRAMPROC glUseProgram;
PFNGLUNIFORM1FPROC glUniform1f;
PFNGLUNIFORM2FPROC glUniform2f;
PFNGLUNIFORM3FPROC glUniform3f;
PFNGLUNIFORM4FPROC glUniform4f;
PFNGLUNIFORM1IPROC glUniform1i;
PFNGLUNIFORM2IPROC glUniform2i;
PFNGLUNIFORM3IPROC glUniform3i;
PFNGLUNIFORM4IPROC glUniform4i;
PFNGLUNIFORM1FVPROC glUniform1fv;
PFNGLUNIFORM2FVPROC glUniform2fv;
PFNGLUNIFORM3FVPROC glUniform3fv;
PFNGLUNIFORM4FVPROC glUniform4fv;
PFNGLUNIFORM1IVPROC glUniform1iv;
PFNGLUNIFORM2IVPROC glUniform2iv;
PFNGLUNIFORM3IVPROC glUniform3iv;
PFNGLUNIFORM4IVPROC glUniform4iv;
PFNGLUNIFORMMATRIX2FVPROC glUniformMatrix2fv;
PFNGLUNIFORMMATRIX3FVPROC glUniformMatrix3fv;
PFNGLUNIFORMMATRIX4FVPROC glUniformMatrix4fv;
PFNGLVALIDATEPROGRAMPROC glValidateProgram;
PFNGLVERTEXATTRIB1DPROC glVertexAttrib1d;
PFNGLVERTEXATTRIB1DVPROC glVertexAttrib1dv;
PFNGLVERTEXATTRIB1FPROC glVertexAttrib1f;
PFNGLVERTEXATTRIB1FVPROC glVertexAttrib1fv;
PFNGLVERTEXATTRIB1SPROC glVertexAttrib1s;
PFNGLVERTEXATTRIB1SVPROC glVertexAttrib1sv;
PFNGLVERTEXATTRIB2DPROC glVertexAttrib2d;
PFNGLVERTEXATTRIB2DVPROC glVertexAttrib2dv;
PFNGLVERTEXATTRIB2FPROC glVertexAttrib2f;
PFNGLVERTEXATTRIB2FVPROC glVertexAttrib2fv;
PFNGLVERTEXATTRIB2SPROC glVertexAttrib2s;
PFNGLVERTEXATTRIB2SVPROC glVertexAttrib2sv;
PFNGLVERTEXATTRIB3DPROC glVertexAttrib3d;
PFNGLVERTEXATTRIB3DVPROC glVertexAttrib3dv;
PFNGLVERTEXATTRIB3FPROC glVertexAttrib3f;
PFNGLVERTEXATTRIB3FVPROC glVertexAttrib3fv;
PFNGLVERTEXATTRIB3SPROC glVertexAttrib3s;
PFNGLVERTEXATTRIB3SVPROC glVertexAttrib3sv;
PFNGLVERTEXATTRIB4NBVPROC glVertexAttrib4Nbv;
PFNGLVERTEXATTRIB4NIVPROC glVertexAttrib4Niv;
PFNGLVERTEXATTRIB4NSVPROC glVertexAttrib4Nsv;
PFNGLVERTEXATTRIB4NUBPROC glVertexAttrib4Nub;
PFNGLVERTEXATTRIB4NUBVPROC glVertexAttrib4Nubv;
PFNGLVERTEXATTRIB4NUIVPROC glVertexAttrib4Nuiv;
PFNGLVERTEXATTRIB4NUSVPROC glVertexAttrib4Nusv;
PFNGLVERTEXATTRIB4BVPROC glVertexAttrib4bv;
PFNGLVERTEXATTRIB4DPROC glVertexAttrib4d;
PFNGLVERTEXATTRIB4DVPROC glVertexAttrib4dv;
PFNGLVERTEXATTRIB4FPROC glVertexAttrib4f;
PFNGLVERTEXATTRIB4FVPROC glVertexAttrib4fv;
PFNGLVERTEXATTRIB4IVPROC glVertexAttrib4iv;
PFNGLVERTEXATTRIB4SPROC glVertexAttrib4s;
PFNGLVERTEXATTRIB4SVPROC glVertexAttrib4sv;
PFNGLVERTEXATTRIB4UBVPROC glVertexAttrib4ubv;
PFNGLVERTEXATTRIB4UIVPROC glVertexAttrib4uiv;
PFNGLVERTEXATTRIB4USVPROC glVertexAttrib4usv;
PFNGLVERTEXATTRIBPOINTERPROC glVertexAttribPointer;
PFNGLUNIFORMMATRIX2X3FVPROC glUniformMatrix2x3fv;
PFNGLUNIFORMMATRIX3X2FVPROC glUniformMatrix3x2fv;
PFNGLUNIFORMMATRIX2X4FVPROC glUniformMatrix2x4fv;
PFNGLUNIFORMMATRIX4X2FVPROC glUniformMatrix4x2fv;
PFNGLUNIFORMMATRIX3X4FVPROC glUniformMatrix3x4fv;
PFNGLUNIFORMMATRIX4X3FVPROC glUniformMatrix4x3fv;
PFNGLCOLORMASKIPROC glColorMaski;
PFNGLGETBOOLEANI_VPROC glGetBooleani_v;
PFNGLGETINTEGERI_VPROC glGetIntegeri_v;
PFNGLENABLEIPROC glEnablei;
PFNGLDISABLEIPROC glDisablei;
PFNGLISENABLEDIPROC glIsEnabledi;
PFNGLBEGINTRANSFORMFEEDBACKPROC glBeginTransformFeedback;
PFNGLENDTRANSFORMFEEDBACKPROC glEndTransformFeedback;
PFNGLBINDBUFFERRANGEPROC glBindBufferRange;
PFNGLBINDBUFFERBASEPROC glBindBufferBase;
PFNGLTRANSFORMFEEDBACKVARYINGSPROC glTransformFeedbackVaryings;
PFNGLGETTRANSFORMFEEDBACKVARYINGPROC glGetTransformFeedbackVarying;
PFNGLCLAMPCOLORPROC glClampColor;
PFNGLBEGINCONDITIONALRENDERPROC glBeginConditionalRender;
PFNGLENDCONDITIONALRENDERPROC glEndConditionalRender;
PFNGLVERTEXATTRIBIPOINTERPROC glVertexAttribIPointer;
PFNGLGETVERTEXATTRIBIIVPROC glGetVertexAttribIiv;
PFNGLGETVERTEXATTRIBIUIVPROC glGetVertexAttribIuiv;
PFNGLVERTEXATTRIBI1IPROC glVertexAttribI1i;
PFNGLVERTEXATTRIBI2IPROC glVertexAttribI2i;
PFNGLVERTEXATTRIBI3IPROC glVertexAttribI3i;
PFNGLVERTEXATTRIBI4IPROC glVertexAttribI4i;
PFNGLVERTEXATTRIBI1UIPROC glVertexAttribI1ui;
PFNGLVERTEXATTRIBI2UIPROC glVertexAttribI2ui;
PFNGLVERTEXATTRIBI3UIPROC glVertexAttribI3ui;
PFNGLVERTEXATTRIBI4UIPROC glVertexAttribI4ui;
PFNGLVERTEXATTRIBI1IVPROC glVertexAttribI1iv;
PFNGLVERTEXATTRIBI2IVPROC glVertexAttribI2iv;
PFNGLVERTEXATTRIBI3IVPROC glVertexAttribI3iv;
PFNGLVERTEXATTRIBI4IVPROC glVertexAttribI4iv;
PFNGLVERTEXATTRIBI1UIVPROC glVertexAttribI1uiv;
PFNGLVERTEXATTRIBI2UIVPROC glVertexAttribI2uiv;
PFNGLVERTEXATTRIBI3UIVPROC glVertexAttribI3uiv;
PFNGLVERTEXATTRIBI4UIVPROC glVertexAttribI4uiv;
PFNGLVERTEXATTRIBI4BVPROC glVertexAttribI4bv;
PFNGLVERTEXATTRIBI4SVPROC glVertexAttribI4sv;
PFNGLVERTEXATTRIBI4UBVPROC glVertexAttribI4ubv;
PFNGLVERTEXATTRIBI4USVPROC glVertexAttribI4usv;
PFNGLGETUNIFORMUIVPROC glGetUniformuiv;
PFNGLBINDFRAGDATALOCATIONPROC glBindFragDataLocation;
PFNGLGETFRAGDATALOCATIONPROC glGetFragDataLocation;
PFNGLUNIFORM1UIPROC glUniform1ui;
PFNGLUNIFORM2UIPROC glUniform2ui;
PFNGLUNIFORM3UIPROC glUniform3ui;
PFNGLUNIFORM4UIPROC glUniform4ui;
PFNGLUNIFORM1UIVPROC glUniform1uiv;
PFNGLUNIFORM2UIVPROC glUniform2uiv;
PFNGLUNIFORM3UIVPROC glUniform3uiv;
PFNGLUNIFORM4UIVPROC glUniform4uiv;
PFNGLTEXPARAMETERIIVPROC glTexParameterIiv;
PFNGLTEXPARAMETERIUIVPROC glTexParameterIuiv;
PFNGLGETTEXPARAMETERIIVPROC glGetTexParameterIiv;
PFNGLGETTEXPARAMETERIUIVPROC glGetTexParameterIuiv;
PFNGLCLEARBUFFERIVPROC glClearBufferiv;
PFNGLCLEARBUFFERUIVPROC glClearBufferuiv;
PFNGLCLEARBUFFERFVPROC glClearBufferfv;
PFNGLCLEARBUFFERFIPROC glClearBufferfi;
PFNGLGETSTRINGIPROC glGetStringi;
PFNGLDRAWARRAYSINSTANCEDPROC glDrawArraysInstanced;
PFNGLDRAWELEMENTSINSTANCEDPROC glDrawElementsInstanced;
PFNGLTEXBUFFERPROC glTexBuffer;
PFNGLPRIMITIVERESTARTINDEXPROC glPrimitiveRestartIndex;
PFNGLGETINTEGER64I_VPROC glGetInteger64i_v;
PFNGLGETBUFFERPARAMETERI64VPROC glGetBufferParameteri64v;
PFNGLFRAMEBUFFERTEXTUREPROC glFramebufferTexture;
PFNGLVERTEXATTRIBDIVISORPROC glVertexAttribDivisor;
PFNGLMINSAMPLESHADINGPROC glMinSampleShading;
PFNGLBLENDEQUATIONIPROC glBlendEquationi;
PFNGLBLENDEQUATIONSEPARATEIPROC glBlendEquationSeparatei;
PFNGLBLENDFUNCIPROC glBlendFunci;
PFNGLBLENDFUNCSEPARATEIPROC glBlendFuncSeparatei;
PFNGLISRENDERBUFFERPROC glIsRenderbuffer;
PFNGLBINDRENDERBUFFERPROC glBindRenderbuffer;
PFNGLDELETERENDERBUFFERSPROC glDeleteRenderbuffers;
PFNGLGENRENDERBUFFERSPROC glGenRenderbuffers;
PFNGLRENDERBUFFERSTORAGEPROC glRenderbufferStorage;
PFNGLGETRENDERBUFFERPARAMETERIVPROC glGetRenderbufferParameteriv;
PFNGLISFRAMEBUFFERPROC glIsFramebuffer;
PFNGLBINDFRAMEBUFFERPROC glBindFramebuffer;
PFNGLDELETEFRAMEBUFFERSPROC glDeleteFramebuffers;
PFNGLGENFRAMEBUFFERSPROC glGenFramebuffers;
PFNGLCHECKFRAMEBUFFERSTATUSPROC glCheckFramebufferStatus;
PFNGLFRAMEBUFFERTEXTURE1DPROC glFramebufferTexture1D;
PFNGLFRAMEBUFFERTEXTURE2DPROC glFramebufferTexture2D;
PFNGLFRAMEBUFFERTEXTURE3DPROC glFramebufferTexture3D;
PFNGLFRAMEBUFFERRENDERBUFFERPROC glFramebufferRenderbuffer;
PFNGLGETFRAMEBUFFERATTACHMENTPARAMETERIVPROC glGetFramebufferAttachmentParameteriv;
PFNGLGENERATEMIPMAPPROC glGenerateMipmap;
PFNGLBLITFRAMEBUFFERPROC glBlitFramebuffer;
PFNGLRENDERBUFFERSTORAGEMULTISAMPLEPROC glRenderbufferStorageMultisample;
PFNGLFRAMEBUFFERTEXTURELAYERPROC glFramebufferTextureLayer;
PFNGLMAPBUFFERRANGEPROC glMapBufferRange;
PFNGLFLUSHMAPPEDBUFFERRANGEPROC glFlushMappedBufferRange;
PFNGLBINDVERTEXARRAYPROC glBindVertexArray;
PFNGLDELETEVERTEXARRAYSPROC glDeleteVertexArrays;
PFNGLGENVERTEXARRAYSPROC glGenVertexArrays;
PFNGLISVERTEXARRAYPROC glIsVertexArray;
PFNGLGETUNIFORMINDICESPROC glGetUniformIndices;
PFNGLGETACTIVEUNIFORMSIVPROC glGetActiveUniformsiv;
PFNGLGETACTIVEUNIFORMNAMEPROC glGetActiveUniformName;
PFNGLGETUNIFORMBLOCKINDEXPROC glGetUniformBlockIndex;
PFNGLGETACTIVEUNIFORMBLOCKIVPROC glGetActiveUniformBlockiv;
PFNGLGETACTIVEUNIFORMBLOCKNAMEPROC glGetActiveUniformBlockName;
PFNGLUNIFORMBLOCKBINDINGPROC glUniformBlockBinding;
PFNGLCOPYBUFFERSUBDATAPROC glCopyBufferSubData;
PFNGLDRAWELEMENTSBASEVERTEXPROC glDrawElementsBaseVertex;
PFNGLDRAWRANGEELEMENTSBASEVERTEXPROC glDrawRangeElementsBaseVertex;
PFNGLDRAWELEMENTSINSTANCEDBASEVERTEXPROC glDrawElementsInstancedBaseVertex;
PFNGLMULTIDRAWELEMENTSBASEVERTEXPROC glMultiDrawElementsBaseVertex;
PFNGLPROVOKINGVERTEXPROC glProvokingVertex;
PFNGLFENCESYNCPROC glFenceSync;
PFNGLISSYNCPROC glIsSync;
PFNGLDELETESYNCPROC glDeleteSync;
PFNGLCLIENTWAITSYNCPROC glClientWaitSync;
PFNGLWAITSYNCPROC glWaitSync;
PFNGLGETINTEGER64VPROC glGetInteger64v;
PFNGLGETSYNCIVPROC glGetSynciv;
PFNGLTEXIMAGE2DMULTISAMPLEPROC glTexImage2DMultisample;
PFNGLTEXIMAGE3DMULTISAMPLEPROC glTexImage3DMultisample;
PFNGLGETMULTISAMPLEFVPROC glGetMultisamplefv;
PFNGLSAMPLEMASKIPROC glSampleMaski;
PFNGLBINDFRAGDATALOCATIONINDEXEDPROC glBindFragDataLocationIndexed;
PFNGLGETFRAGDATAINDEXPROC glGetFragDataIndex;
PFNGLGENSAMPLERSPROC glGenSamplers;
PFNGLDELETESAMPLERSPROC glDeleteSamplers;
PFNGLISSAMPLERPROC glIsSampler;
PFNGLBINDSAMPLERPROC glBindSampler;
PFNGLSAMPLERPARAMETERIPROC glSamplerParameteri;
PFNGLSAMPLERPARAMETERIVPROC glSamplerParameteriv;
PFNGLSAMPLERPARAMETERFPROC glSamplerParameterf;
PFNGLSAMPLERPARAMETERFVPROC glSamplerParameterfv;
PFNGLSAMPLERPARAMETERIIVPROC glSamplerParameterIiv;
PFNGLSAMPLERPARAMETERIUIVPROC glSamplerParameterIuiv;
PFNGLGETSAMPLERPARAMETERIVPROC glGetSamplerParameteriv;
PFNGLGETSAMPLERPARAMETERIIVPROC glGetSamplerParameterIiv;
PFNGLGETSAMPLERPARAMETERFVPROC glGetSamplerParameterfv;
PFNGLGETSAMPLERPARAMETERIUIVPROC glGetSamplerParameterIuiv;
PFNGLQUERYCOUNTERPROC glQueryCounter;
PFNGLGETQUERYOBJECTI64VPROC glGetQueryObjecti64v;
PFNGLGETQUERYOBJECTUI64VPROC glGetQueryObjectui64v;
PFNGLVERTEXP2UIPROC glVertexP2ui;
PFNGLVERTEXP2UIVPROC glVertexP2uiv;
PFNGLVERTEXP3UIPROC glVertexP3ui;
PFNGLVERTEXP3UIVPROC glVertexP3uiv;
PFNGLVERTEXP4UIPROC glVertexP4ui;
PFNGLVERTEXP4UIVPROC glVertexP4uiv;
PFNGLTEXCOORDP1UIPROC glTexCoordP1ui;
PFNGLTEXCOORDP1UIVPROC glTexCoordP1uiv;
PFNGLTEXCOORDP2UIPROC glTexCoordP2ui;
PFNGLTEXCOORDP2UIVPROC glTexCoordP2uiv;
PFNGLTEXCOORDP3UIPROC glTexCoordP3ui;
PFNGLTEXCOORDP3UIVPROC glTexCoordP3uiv;
PFNGLTEXCOORDP4UIPROC glTexCoordP4ui;
PFNGLTEXCOORDP4UIVPROC glTexCoordP4uiv;
PFNGLMULTITEXCOORDP1UIPROC glMultiTexCoordP1ui;
PFNGLMULTITEXCOORDP1UIVPROC glMultiTexCoordP1uiv;
PFNGLMULTITEXCOORDP2UIPROC glMultiTexCoordP2ui;
PFNGLMULTITEXCOORDP2UIVPROC glMultiTexCoordP2uiv;
PFNGLMULTITEXCOORDP3UIPROC glMultiTexCoordP3ui;
PFNGLMULTITEXCOORDP3UIVPROC glMultiTexCoordP3uiv;
PFNGLMULTITEXCOORDP4UIPROC glMultiTexCoordP4ui;
PFNGLMULTITEXCOORDP4UIVPROC glMultiTexCoordP4uiv;
PFNGLNORMALP3UIPROC glNormalP3ui;
PFNGLNORMALP3UIVPROC glNormalP3uiv;
PFNGLCOLORP3UIPROC glColorP3ui;
PFNGLCOLORP3UIVPROC glColorP3uiv;
PFNGLCOLORP4UIPROC glColorP4ui;
PFNGLCOLORP4UIVPROC glColorP4uiv;
PFNGLSECONDARYCOLORP3UIPROC glSecondaryColorP3ui;
PFNGLSECONDARYCOLORP3UIVPROC glSecondaryColorP3uiv;
PFNGLVERTEXATTRIBP1UIPROC glVertexAttribP1ui;
PFNGLVERTEXATTRIBP1UIVPROC glVertexAttribP1uiv;
PFNGLVERTEXATTRIBP2UIPROC glVertexAttribP2ui;
PFNGLVERTEXATTRIBP2UIVPROC glVertexAttribP2uiv;
PFNGLVERTEXATTRIBP3UIPROC glVertexAttribP3ui;
PFNGLVERTEXATTRIBP3UIVPROC glVertexAttribP3uiv;
PFNGLVERTEXATTRIBP4UIPROC glVertexAttribP4ui;
PFNGLVERTEXATTRIBP4UIVPROC glVertexAttribP4uiv;
PFNGLDRAWARRAYSINDIRECTPROC glDrawArraysIndirect;
PFNGLDRAWELEMENTSINDIRECTPROC glDrawElementsIndirect;
PFNGLUNIFORM1DPROC glUniform1d;
PFNGLUNIFORM2DPROC glUniform2d;
PFNGLUNIFORM3DPROC glUniform3d;
PFNGLUNIFORM4DPROC glUniform4d;
PFNGLUNIFORM1DVPROC glUniform1dv;
PFNGLUNIFORM2DVPROC glUniform2dv;
PFNGLUNIFORM3DVPROC glUniform3dv;
PFNGLUNIFORM4DVPROC glUniform4dv;
PFNGLUNIFORMMATRIX2DVPROC glUniformMatrix2dv;
PFNGLUNIFORMMATRIX3DVPROC glUniformMatrix3dv;
PFNGLUNIFORMMATRIX4DVPROC glUniformMatrix4dv;
PFNGLUNIFORMMATRIX2X3DVPROC glUniformMatrix2x3dv;
PFNGLUNIFORMMATRIX2X4DVPROC glUniformMatrix2x4dv;
PFNGLUNIFORMMATRIX3X2DVPROC glUniformMatrix3x2dv;
PFNGLUNIFORMMATRIX3X4DVPROC glUniformMatrix3x4dv;
PFNGLUNIFORMMATRIX4X2DVPROC glUniformMatrix4x2dv;
PFNGLUNIFORMMATRIX4X3DVPROC glUniformMatrix4x3dv;
PFNGLGETUNIFORMDVPROC glGetUniformdv;
PFNGLGETSUBROUTINEUNIFORMLOCATIONPROC glGetSubroutineUniformLocation;
PFNGLGETSUBROUTINEINDEXPROC glGetSubroutineIndex;
PFNGLGETACTIVESUBROUTINEUNIFORMIVPROC glGetActiveSubroutineUniformiv;
PFNGLGETACTIVESUBROUTINEUNIFORMNAMEPROC glGetActiveSubroutineUniformName;
PFNGLGETACTIVESUBROUTINENAMEPROC glGetActiveSubroutineName;
PFNGLUNIFORMSUBROUTINESUIVPROC glUniformSubroutinesuiv;
PFNGLGETUNIFORMSUBROUTINEUIVPROC glGetUniformSubroutineuiv;
PFNGLGETPROGRAMSTAGEIVPROC glGetProgramStageiv;
PFNGLPATCHPARAMETERIPROC glPatchParameteri;
PFNGLPATCHPARAMETERFVPROC glPatchParameterfv;
PFNGLBINDTRANSFORMFEEDBACKPROC glBindTransformFeedback;
PFNGLDELETETRANSFORMFEEDBACKSPROC glDeleteTransformFeedbacks;
PFNGLGENTRANSFORMFEEDBACKSPROC glGenTransformFeedbacks;
PFNGLISTRANSFORMFEEDBACKPROC glIsTransformFeedback;
PFNGLPAUSETRANSFORMFEEDBACKPROC glPauseTransformFeedback;
PFNGLRESUMETRANSFORMFEEDBACKPROC glResumeTransformFeedback;
PFNGLDRAWTRANSFORMFEEDBACKPROC glDrawTransformFeedback;
PFNGLDRAWTRANSFORMFEEDBACKSTREAMPROC glDrawTransformFeedbackStream;
PFNGLBEGINQUERYINDEXEDPROC glBeginQueryIndexed;
PFNGLENDQUERYINDEXEDPROC glEndQueryIndexed;
PFNGLGETQUERYINDEXEDIVPROC glGetQueryIndexediv;
PFNGLRELEASESHADERCOMPILERPROC glReleaseShaderCompiler;
PFNGLSHADERBINARYPROC glShaderBinary;
PFNGLGETSHADERPRECISIONFORMATPROC glGetShaderPrecisionFormat;
PFNGLDEPTHRANGEFPROC glDepthRangef;
PFNGLCLEARDEPTHFPROC glClearDepthf;
PFNGLGETPROGRAMBINARYPROC glGetProgramBinary;
PFNGLPROGRAMBINARYPROC glProgramBinary;
PFNGLPROGRAMPARAMETERIPROC glProgramParameteri;
PFNGLUSEPROGRAMSTAGESPROC glUseProgramStages;
PFNGLACTIVESHADERPROGRAMPROC glActiveShaderProgram;
PFNGLCREATESHADERPROGRAMVPROC glCreateShaderProgramv;
PFNGLBINDPROGRAMPIPELINEPROC glBindProgramPipeline;
PFNGLDELETEPROGRAMPIPELINESPROC glDeleteProgramPipelines;
PFNGLGENPROGRAMPIPELINESPROC glGenProgramPipelines;
PFNGLISPROGRAMPIPELINEPROC glIsProgramPipeline;
PFNGLGETPROGRAMPIPELINEIVPROC glGetProgramPipelineiv;
PFNGLPROGRAMUNIFORM1IPROC glProgramUniform1i;
PFNGLPROGRAMUNIFORM1IVPROC glProgramUniform1iv;
PFNGLPROGRAMUNIFORM1FPROC glProgramUniform1f;
PFNGLPROGRAMUNIFORM1FVPROC glProgramUniform1fv;
PFNGLPROGRAMUNIFORM1DPROC glProgramUniform1d;
PFNGLPROGRAMUNIFORM1DVPROC glProgramUniform1dv;
PFNGLPROGRAMUNIFORM1UIPROC glProgramUniform1ui;
PFNGLPROGRAMUNIFORM1UIVPROC glProgramUniform1uiv;
PFNGLPROGRAMUNIFORM2IPROC glProgramUniform2i;
PFNGLPROGRAMUNIFORM2IVPROC glProgramUniform2iv;
PFNGLPROGRAMUNIFORM2FPROC glProgramUniform2f;
PFNGLPROGRAMUNIFORM2FVPROC glProgramUniform2fv;
PFNGLPROGRAMUNIFORM2DPROC glProgramUniform2d;
PFNGLPROGRAMUNIFORM2DVPROC glProgramUniform2dv;
PFNGLPROGRAMUNIFORM2UIPROC glProgramUniform2ui;
PFNGLPROGRAMUNIFORM2UIVPROC glProgramUniform2uiv;
PFNGLPROGRAMUNIFORM3IPROC glProgramUniform3i;
PFNGLPROGRAMUNIFORM3IVPROC glProgramUniform3iv;
PFNGLPROGRAMUNIFORM3FPROC glProgramUniform3f;
PFNGLPROGRAMUNIFORM3FVPROC glProgramUniform3fv;
PFNGLPROGRAMUNIFORM3DPROC glProgramUniform3d;
PFNGLPROGRAMUNIFORM3DVPROC glProgramUniform3dv;
PFNGLPROGRAMUNIFORM3UIPROC glProgramUniform3ui;
PFNGLPROGRAMUNIFORM3UIVPROC glProgramUniform3uiv;
PFNGLPROGRAMUNIFORM4IPROC glProgramUniform4i;
PFNGLPROGRAMUNIFORM4IVPROC glProgramUniform4iv;
PFNGLPROGRAMUNIFORM4FPROC glProgramUniform4f;
PFNGLPROGRAMUNIFORM4FVPROC glProgramUniform4fv;
PFNGLPROGRAMUNIFORM4DPROC glProgramUniform4d;
PFNGLPROGRAMUNIFORM4DVPROC glProgramUniform4dv;
PFNGLPROGRAMUNIFORM4UIPROC glProgramUniform4ui;
PFNGLPROGRAMUNIFORM4UIVPROC glProgramUniform4uiv;
PFNGLPROGRAMUNIFORMMATRIX2FVPROC glProgramUniformMatrix2fv;
PFNGLPROGRAMUNIFORMMATRIX3FVPROC glProgramUniformMatrix3fv;
PFNGLPROGRAMUNIFORMMATRIX4FVPROC glProgramUniformMatrix4fv;
PFNGLPROGRAMUNIFORMMATRIX2DVPROC glProgramUniformMatrix2dv;
PFNGLPROGRAMUNIFORMMATRIX3DVPROC glProgramUniformMatrix3dv;
PFNGLPROGRAMUNIFORMMATRIX4DVPROC glProgramUniformMatrix4dv;
PFNGLPROGRAMUNIFORMMATRIX2X3FVPROC glProgramUniformMatrix2x3fv;
PFNGLPROGRAMUNIFORMMATRIX3X2FVPROC glProgramUniformMatrix3x2fv;
PFNGLPROGRAMUNIFORMMATRIX2X4FVPROC glProgramUniformMatrix2x4fv;
PFNGLPROGRAMUNIFORMMATRIX4X2FVPROC glProgramUniformMatrix4x2fv;
PFNGLPROGRAMUNIFORMMATRIX3X4FVPROC glProgramUniformMatrix3x4fv;
PFNGLPROGRAMUNIFORMMATRIX4X3FVPROC glProgramUniformMatrix4x3fv;
PFNGLPROGRAMUNIFORMMATRIX2X3DVPROC glProgramUniformMatrix2x3dv;
PFNGLPROGRAMUNIFORMMATRIX3X2DVPROC glProgramUniformMatrix3x2dv;
PFNGLPROGRAMUNIFORMMATRIX2X4DVPROC glProgramUniformMatrix2x4dv;
PFNGLPROGRAMUNIFORMMATRIX4X2DVPROC glProgramUniformMatrix4x2dv;
PFNGLPROGRAMUNIFORMMATRIX3X4DVPROC glProgramUniformMatrix3x4dv;
PFNGLPROGRAMUNIFORMMATRIX4X3DVPROC glProgramUniformMatrix4x3dv;
PFNGLVALIDATEPROGRAMPIPELINEPROC glValidateProgramPipeline;
PFNGLGETPROGRAMPIPELINEINFOLOGPROC glGetProgramPipelineInfoLog;
PFNGLVERTEXATTRIBL1DPROC glVertexAttribL1d;
PFNGLVERTEXATTRIBL2DPROC glVertexAttribL2d;
PFNGLVERTEXATTRIBL3DPROC glVertexAttribL3d;
PFNGLVERTEXATTRIBL4DPROC glVertexAttribL4d;
PFNGLVERTEXATTRIBL1DVPROC glVertexAttribL1dv;
PFNGLVERTEXATTRIBL2DVPROC glVertexAttribL2dv;
PFNGLVERTEXATTRIBL3DVPROC glVertexAttribL3dv;
PFNGLVERTEXATTRIBL4DVPROC glVertexAttribL4dv;
PFNGLVERTEXATTRIBLPOINTERPROC glVertexAttribLPointer;
PFNGLGETVERTEXATTRIBLDVPROC glGetVertexAttribLdv;
PFNGLVIEWPORTARRAYVPROC glViewportArrayv;
PFNGLVIEWPORTINDEXEDFPROC glViewportIndexedf;
PFNGLVIEWPORTINDEXEDFVPROC glViewportIndexedfv;
PFNGLSCISSORARRAYVPROC glScissorArrayv;
PFNGLSCISSORINDEXEDPROC glScissorIndexed;
PFNGLSCISSORINDEXEDVPROC glScissorIndexedv;
PFNGLDEPTHRANGEARRAYVPROC glDepthRangeArrayv;
PFNGLDEPTHRANGEINDEXEDPROC glDepthRangeIndexed;
PFNGLGETFLOATI_VPROC glGetFloati_v;
PFNGLGETDOUBLEI_VPROC glGetDoublei_v;
PFNGLDRAWARRAYSINSTANCEDBASEINSTANCEPROC glDrawArraysInstancedBaseInstance;
PFNGLDRAWELEMENTSINSTANCEDBASEINSTANCEPROC glDrawElementsInstancedBaseInstance;
PFNGLDRAWELEMENTSINSTANCEDBASEVERTEXBASEINSTANCEPROC glDrawElementsInstancedBaseVertexBaseInstance;
PFNGLDRAWTRANSFORMFEEDBACKINSTANCEDPROC glDrawTransformFeedbackInstanced;
PFNGLDRAWTRANSFORMFEEDBACKSTREAMINSTANCEDPROC glDrawTransformFeedbackStreamInstanced;
PFNGLGETINTERNALFORMATIVPROC glGetInternalformativ;
PFNGLGETACTIVEATOMICCOUNTERBUFFERIVPROC glGetActiveAtomicCounterBufferiv;
PFNGLBINDIMAGETEXTUREPROC glBindImageTexture;
PFNGLMEMORYBARRIERPROC glMemoryBarrier;
PFNGLTEXSTORAGE1DPROC glTexStorage1D;
PFNGLTEXSTORAGE2DPROC glTexStorage2D;
PFNGLTEXSTORAGE3DPROC glTexStorage3D;
PFNGLDEBUGMESSAGECONTROLPROC glDebugMessageControl;
PFNGLDEBUGMESSAGEINSERTPROC glDebugMessageInsert;
PFNGLDEBUGMESSAGECALLBACKPROC glDebugMessageCallback;
PFNGLGETDEBUGMESSAGELOGPROC glGetDebugMessageLog;
PFNGLPUSHDEBUGGROUPPROC glPushDebugGroup;
PFNGLPOPDEBUGGROUPPROC glPopDebugGroup;
PFNGLOBJECTLABELPROC glObjectLabel;
PFNGLGETOBJECTLABELPROC glGetObjectLabel;
PFNGLOBJECTPTRLABELPROC glObjectPtrLabel;
PFNGLGETOBJECTPTRLABELPROC glGetObjectPtrLabel;
PFNGLCLEARBUFFERDATAPROC glClearBufferData;
PFNGLCLEARBUFFERSUBDATAPROC glClearBufferSubData;
PFNGLDISPATCHCOMPUTEPROC glDispatchCompute;
PFNGLDISPATCHCOMPUTEINDIRECTPROC glDispatchComputeIndirect;
PFNGLCOPYIMAGESUBDATAPROC glCopyImageSubData;
PFNGLTEXTUREVIEWPROC glTextureView;
PFNGLBINDVERTEXBUFFERPROC glBindVertexBuffer;
PFNGLVERTEXATTRIBFORMATPROC glVertexAttribFormat;
PFNGLVERTEXATTRIBIFORMATPROC glVertexAttribIFormat;
PFNGLVERTEXATTRIBLFORMATPROC glVertexAttribLFormat;
PFNGLVERTEXATTRIBBINDINGPROC glVertexAttribBinding;
PFNGLVERTEXBINDINGDIVISORPROC glVertexBindingDivisor;
PFNGLFRAMEBUFFERPARAMETERIPROC glFramebufferParameteri;
PFNGLGETFRAMEBUFFERPARAMETERIVPROC glGetFramebufferParameteriv;
PFNGLGETINTERNALFORMATI64VPROC glGetInternalformati64v;
PFNGLINVALIDATETEXSUBIMAGEPROC glInvalidateTexSubImage;
PFNGLINVALIDATETEXIMAGEPROC glInvalidateTexImage;
PFNGLINVALIDATEBUFFERSUBDATAPROC glInvalidateBufferSubData;
PFNGLINVALIDATEBUFFERDATAPROC glInvalidateBufferData;
PFNGLINVALIDATEFRAMEBUFFERPROC glInvalidateFramebuffer;
PFNGLINVALIDATESUBFRAMEBUFFERPROC glInvalidateSubFramebuffer;
PFNGLMULTIDRAWARRAYSINDIRECTPROC glMultiDrawArraysIndirect;
PFNGLMULTIDRAWELEMENTSINDIRECTPROC glMultiDrawElementsIndirect;
PFNGLGETPROGRAMINTERFACEIVPROC glGetProgramInterfaceiv;
PFNGLGETPROGRAMRESOURCEINDEXPROC glGetProgramResourceIndex;
PFNGLGETPROGRAMRESOURCENAMEPROC glGetProgramResourceName;
PFNGLGETPROGRAMRESOURCEIVPROC glGetProgramResourceiv;
PFNGLGETPROGRAMRESOURCELOCATIONPROC glGetProgramResourceLocation;
PFNGLGETPROGRAMRESOURCELOCATIONINDEXPROC glGetProgramResourceLocationIndex;
PFNGLSHADERSTORAGEBLOCKBINDINGPROC glShaderStorageBlockBinding;
PFNGLTEXBUFFERRANGEPROC glTexBufferRange;
PFNGLTEXSTORAGE2DMULTISAMPLEPROC glTexStorage2DMultisample;
PFNGLTEXSTORAGE3DMULTISAMPLEPROC glTexStorage3DMultisample;

static inline void initGLExtFunc(void)
{
  glBlendColor = (PFNGLBLENDCOLORPROC)glfwGetProcAddress("glBlendColor");
  glBlendEquation = (PFNGLBLENDEQUATIONPROC)glfwGetProcAddress("glBlendEquation");
  glDrawRangeElements = (PFNGLDRAWRANGEELEMENTSPROC)glfwGetProcAddress("glDrawRangeElements");
  glTexImage3D = (PFNGLTEXIMAGE3DPROC)glfwGetProcAddress("glTexImage3D");
  glTexSubImage3D = (PFNGLTEXSUBIMAGE3DPROC)glfwGetProcAddress("glTexSubImage3D");
  glCopyTexSubImage3D = (PFNGLCOPYTEXSUBIMAGE3DPROC)glfwGetProcAddress("glCopyTexSubImage3D");
  glColorTable = (PFNGLCOLORTABLEPROC)glfwGetProcAddress("glColorTable");
  glColorTableParameterfv = (PFNGLCOLORTABLEPARAMETERFVPROC)glfwGetProcAddress("glColorTableParameterfv");
  glColorTableParameteriv = (PFNGLCOLORTABLEPARAMETERIVPROC)glfwGetProcAddress("glColorTableParameteriv");
  glCopyColorTable = (PFNGLCOPYCOLORTABLEPROC)glfwGetProcAddress("glCopyColorTable");
  glGetColorTable = (PFNGLGETCOLORTABLEPROC)glfwGetProcAddress("glGetColorTable");
  glGetColorTableParameterfv = (PFNGLGETCOLORTABLEPARAMETERFVPROC)glfwGetProcAddress("glGetColorTableParameterfv");
  glGetColorTableParameteriv = (PFNGLGETCOLORTABLEPARAMETERIVPROC)glfwGetProcAddress("glGetColorTableParameteriv");
  glColorSubTable = (PFNGLCOLORSUBTABLEPROC)glfwGetProcAddress("glColorSubTable");
  glCopyColorSubTable = (PFNGLCOPYCOLORSUBTABLEPROC)glfwGetProcAddress("glCopyColorSubTable");
  glConvolutionFilter1D = (PFNGLCONVOLUTIONFILTER1DPROC)glfwGetProcAddress("glConvolutionFilter1D");
  glConvolutionFilter2D = (PFNGLCONVOLUTIONFILTER2DPROC)glfwGetProcAddress("glConvolutionFilter2D");
  glConvolutionParameterf = (PFNGLCONVOLUTIONPARAMETERFPROC)glfwGetProcAddress("glConvolutionParameterf");
  glConvolutionParameterfv = (PFNGLCONVOLUTIONPARAMETERFVPROC)glfwGetProcAddress("glConvolutionParameterfv");
  glConvolutionParameteri = (PFNGLCONVOLUTIONPARAMETERIPROC)glfwGetProcAddress("glConvolutionParameteri");
  glConvolutionParameteriv = (PFNGLCONVOLUTIONPARAMETERIVPROC)glfwGetProcAddress("glConvolutionParameteriv");
  glCopyConvolutionFilter1D = (PFNGLCOPYCONVOLUTIONFILTER1DPROC)glfwGetProcAddress("glCopyConvolutionFilter1D");
  glCopyConvolutionFilter2D = (PFNGLCOPYCONVOLUTIONFILTER2DPROC)glfwGetProcAddress("glCopyConvolutionFilter2D");
  glGetConvolutionFilter = (PFNGLGETCONVOLUTIONFILTERPROC)glfwGetProcAddress("glGetConvolutionFilter");
  glGetConvolutionParameterfv = (PFNGLGETCONVOLUTIONPARAMETERFVPROC)glfwGetProcAddress("glGetConvolutionParameterfv");
  glGetConvolutionParameteriv = (PFNGLGETCONVOLUTIONPARAMETERIVPROC)glfwGetProcAddress("glGetConvolutionParameteriv");
  glGetSeparableFilter = (PFNGLGETSEPARABLEFILTERPROC)glfwGetProcAddress("glGetSeparableFilter");
  glSeparableFilter2D = (PFNGLSEPARABLEFILTER2DPROC)glfwGetProcAddress("glSeparableFilter2D");
  glGetHistogram = (PFNGLGETHISTOGRAMPROC)glfwGetProcAddress("glGetHistogram");
  glGetHistogramParameterfv = (PFNGLGETHISTOGRAMPARAMETERFVPROC)glfwGetProcAddress("glGetHistogramParameterfv");
  glGetHistogramParameteriv = (PFNGLGETHISTOGRAMPARAMETERIVPROC)glfwGetProcAddress("glGetHistogramParameteriv");
  glGetMinmax = (PFNGLGETMINMAXPROC)glfwGetProcAddress("glGetMinmax");
  glGetMinmaxParameterfv = (PFNGLGETMINMAXPARAMETERFVPROC)glfwGetProcAddress("glGetMinmaxParameterfv");
  glGetMinmaxParameteriv = (PFNGLGETMINMAXPARAMETERIVPROC)glfwGetProcAddress("glGetMinmaxParameteriv");
  glHistogram = (PFNGLHISTOGRAMPROC)glfwGetProcAddress("glHistogram");
  glMinmax = (PFNGLMINMAXPROC)glfwGetProcAddress("glMinmax");
  glResetHistogram = (PFNGLRESETHISTOGRAMPROC)glfwGetProcAddress("glResetHistogram");
  glResetMinmax = (PFNGLRESETMINMAXPROC)glfwGetProcAddress("glResetMinmax");
  glActiveTexture = (PFNGLACTIVETEXTUREPROC)glfwGetProcAddress("glActiveTexture");
  glSampleCoverage = (PFNGLSAMPLECOVERAGEPROC)glfwGetProcAddress("glSampleCoverage");
  glCompressedTexImage3D = (PFNGLCOMPRESSEDTEXIMAGE3DPROC)glfwGetProcAddress("glCompressedTexImage3D");
  glCompressedTexImage2D = (PFNGLCOMPRESSEDTEXIMAGE2DPROC)glfwGetProcAddress("glCompressedTexImage2D");
  glCompressedTexImage1D = (PFNGLCOMPRESSEDTEXIMAGE1DPROC)glfwGetProcAddress("glCompressedTexImage1D");
  glCompressedTexSubImage3D = (PFNGLCOMPRESSEDTEXSUBIMAGE3DPROC)glfwGetProcAddress("glCompressedTexSubImage3D");
  glCompressedTexSubImage2D = (PFNGLCOMPRESSEDTEXSUBIMAGE2DPROC)glfwGetProcAddress("glCompressedTexSubImage2D");
  glCompressedTexSubImage1D = (PFNGLCOMPRESSEDTEXSUBIMAGE1DPROC)glfwGetProcAddress("glCompressedTexSubImage1D");
  glGetCompressedTexImage = (PFNGLGETCOMPRESSEDTEXIMAGEPROC)glfwGetProcAddress("glGetCompressedTexImage");
  glClientActiveTexture = (PFNGLCLIENTACTIVETEXTUREPROC)glfwGetProcAddress("glClientActiveTexture");
  glMultiTexCoord1d = (PFNGLMULTITEXCOORD1DPROC)glfwGetProcAddress("glMultiTexCoord1d");
  glMultiTexCoord1dv = (PFNGLMULTITEXCOORD1DVPROC)glfwGetProcAddress("glMultiTexCoord1dv");
  glMultiTexCoord1f = (PFNGLMULTITEXCOORD1FPROC)glfwGetProcAddress("glMultiTexCoord1f");
  glMultiTexCoord1fv = (PFNGLMULTITEXCOORD1FVPROC)glfwGetProcAddress("glMultiTexCoord1fv");
  glMultiTexCoord1i = (PFNGLMULTITEXCOORD1IPROC)glfwGetProcAddress("glMultiTexCoord1i");
  glMultiTexCoord1iv = (PFNGLMULTITEXCOORD1IVPROC)glfwGetProcAddress("glMultiTexCoord1iv");
  glMultiTexCoord1s = (PFNGLMULTITEXCOORD1SPROC)glfwGetProcAddress("glMultiTexCoord1s");
  glMultiTexCoord1sv = (PFNGLMULTITEXCOORD1SVPROC)glfwGetProcAddress("glMultiTexCoord1sv");
  glMultiTexCoord2d = (PFNGLMULTITEXCOORD2DPROC)glfwGetProcAddress("glMultiTexCoord2d");
  glMultiTexCoord2dv = (PFNGLMULTITEXCOORD2DVPROC)glfwGetProcAddress("glMultiTexCoord2dv");
  glMultiTexCoord2f = (PFNGLMULTITEXCOORD2FPROC)glfwGetProcAddress("glMultiTexCoord2f");
  glMultiTexCoord2fv = (PFNGLMULTITEXCOORD2FVPROC)glfwGetProcAddress("glMultiTexCoord2fv");
  glMultiTexCoord2i = (PFNGLMULTITEXCOORD2IPROC)glfwGetProcAddress("glMultiTexCoord2i");
  glMultiTexCoord2iv = (PFNGLMULTITEXCOORD2IVPROC)glfwGetProcAddress("glMultiTexCoord2iv");
  glMultiTexCoord2s = (PFNGLMULTITEXCOORD2SPROC)glfwGetProcAddress("glMultiTexCoord2s");
  glMultiTexCoord2sv = (PFNGLMULTITEXCOORD2SVPROC)glfwGetProcAddress("glMultiTexCoord2sv");
  glMultiTexCoord3d = (PFNGLMULTITEXCOORD3DPROC)glfwGetProcAddress("glMultiTexCoord3d");
  glMultiTexCoord3dv = (PFNGLMULTITEXCOORD3DVPROC)glfwGetProcAddress("glMultiTexCoord3dv");
  glMultiTexCoord3f = (PFNGLMULTITEXCOORD3FPROC)glfwGetProcAddress("glMultiTexCoord3f");
  glMultiTexCoord3fv = (PFNGLMULTITEXCOORD3FVPROC)glfwGetProcAddress("glMultiTexCoord3fv");
  glMultiTexCoord3i = (PFNGLMULTITEXCOORD3IPROC)glfwGetProcAddress("glMultiTexCoord3i");
  glMultiTexCoord3iv = (PFNGLMULTITEXCOORD3IVPROC)glfwGetProcAddress("glMultiTexCoord3iv");
  glMultiTexCoord3s = (PFNGLMULTITEXCOORD3SPROC)glfwGetProcAddress("glMultiTexCoord3s");
  glMultiTexCoord3sv = (PFNGLMULTITEXCOORD3SVPROC)glfwGetProcAddress("glMultiTexCoord3sv");
  glMultiTexCoord4d = (PFNGLMULTITEXCOORD4DPROC)glfwGetProcAddress("glMultiTexCoord4d");
  glMultiTexCoord4dv = (PFNGLMULTITEXCOORD4DVPROC)glfwGetProcAddress("glMultiTexCoord4dv");
  glMultiTexCoord4f = (PFNGLMULTITEXCOORD4FPROC)glfwGetProcAddress("glMultiTexCoord4f");
  glMultiTexCoord4fv = (PFNGLMULTITEXCOORD4FVPROC)glfwGetProcAddress("glMultiTexCoord4fv");
  glMultiTexCoord4i = (PFNGLMULTITEXCOORD4IPROC)glfwGetProcAddress("glMultiTexCoord4i");
  glMultiTexCoord4iv = (PFNGLMULTITEXCOORD4IVPROC)glfwGetProcAddress("glMultiTexCoord4iv");
  glMultiTexCoord4s = (PFNGLMULTITEXCOORD4SPROC)glfwGetProcAddress("glMultiTexCoord4s");
  glMultiTexCoord4sv = (PFNGLMULTITEXCOORD4SVPROC)glfwGetProcAddress("glMultiTexCoord4sv");
  glLoadTransposeMatrixf = (PFNGLLOADTRANSPOSEMATRIXFPROC)glfwGetProcAddress("glLoadTransposeMatrixf");
  glLoadTransposeMatrixd = (PFNGLLOADTRANSPOSEMATRIXDPROC)glfwGetProcAddress("glLoadTransposeMatrixd");
  glMultTransposeMatrixf = (PFNGLMULTTRANSPOSEMATRIXFPROC)glfwGetProcAddress("glMultTransposeMatrixf");
  glMultTransposeMatrixd = (PFNGLMULTTRANSPOSEMATRIXDPROC)glfwGetProcAddress("glMultTransposeMatrixd");
  glBlendFuncSeparate = (PFNGLBLENDFUNCSEPARATEPROC)glfwGetProcAddress("glBlendFuncSeparate");
  glMultiDrawArrays = (PFNGLMULTIDRAWARRAYSPROC)glfwGetProcAddress("glMultiDrawArrays");
  glMultiDrawElements = (PFNGLMULTIDRAWELEMENTSPROC)glfwGetProcAddress("glMultiDrawElements");
  glPointParameterf = (PFNGLPOINTPARAMETERFPROC)glfwGetProcAddress("glPointParameterf");
  glPointParameterfv = (PFNGLPOINTPARAMETERFVPROC)glfwGetProcAddress("glPointParameterfv");
  glPointParameteri = (PFNGLPOINTPARAMETERIPROC)glfwGetProcAddress("glPointParameteri");
  glPointParameteriv = (PFNGLPOINTPARAMETERIVPROC)glfwGetProcAddress("glPointParameteriv");
  glFogCoordf = (PFNGLFOGCOORDFPROC)glfwGetProcAddress("glFogCoordf");
  glFogCoordfv = (PFNGLFOGCOORDFVPROC)glfwGetProcAddress("glFogCoordfv");
  glFogCoordd = (PFNGLFOGCOORDDPROC)glfwGetProcAddress("glFogCoordd");
  glFogCoorddv = (PFNGLFOGCOORDDVPROC)glfwGetProcAddress("glFogCoorddv");
  glFogCoordPointer = (PFNGLFOGCOORDPOINTERPROC)glfwGetProcAddress("glFogCoordPointer");
  glSecondaryColor3b = (PFNGLSECONDARYCOLOR3BPROC)glfwGetProcAddress("glSecondaryColor3b");
  glSecondaryColor3bv = (PFNGLSECONDARYCOLOR3BVPROC)glfwGetProcAddress("glSecondaryColor3bv");
  glSecondaryColor3d = (PFNGLSECONDARYCOLOR3DPROC)glfwGetProcAddress("glSecondaryColor3d");
  glSecondaryColor3dv = (PFNGLSECONDARYCOLOR3DVPROC)glfwGetProcAddress("glSecondaryColor3dv");
  glSecondaryColor3f = (PFNGLSECONDARYCOLOR3FPROC)glfwGetProcAddress("glSecondaryColor3f");
  glSecondaryColor3fv = (PFNGLSECONDARYCOLOR3FVPROC)glfwGetProcAddress("glSecondaryColor3fv");
  glSecondaryColor3i = (PFNGLSECONDARYCOLOR3IPROC)glfwGetProcAddress("glSecondaryColor3i");
  glSecondaryColor3iv = (PFNGLSECONDARYCOLOR3IVPROC)glfwGetProcAddress("glSecondaryColor3iv");
  glSecondaryColor3s = (PFNGLSECONDARYCOLOR3SPROC)glfwGetProcAddress("glSecondaryColor3s");
  glSecondaryColor3sv = (PFNGLSECONDARYCOLOR3SVPROC)glfwGetProcAddress("glSecondaryColor3sv");
  glSecondaryColor3ub = (PFNGLSECONDARYCOLOR3UBPROC)glfwGetProcAddress("glSecondaryColor3ub");
  glSecondaryColor3ubv = (PFNGLSECONDARYCOLOR3UBVPROC)glfwGetProcAddress("glSecondaryColor3ubv");
  glSecondaryColor3ui = (PFNGLSECONDARYCOLOR3UIPROC)glfwGetProcAddress("glSecondaryColor3ui");
  glSecondaryColor3uiv = (PFNGLSECONDARYCOLOR3UIVPROC)glfwGetProcAddress("glSecondaryColor3uiv");
  glSecondaryColor3us = (PFNGLSECONDARYCOLOR3USPROC)glfwGetProcAddress("glSecondaryColor3us");
  glSecondaryColor3usv = (PFNGLSECONDARYCOLOR3USVPROC)glfwGetProcAddress("glSecondaryColor3usv");
  glSecondaryColorPointer = (PFNGLSECONDARYCOLORPOINTERPROC)glfwGetProcAddress("glSecondaryColorPointer");
  glWindowPos2d = (PFNGLWINDOWPOS2DPROC)glfwGetProcAddress("glWindowPos2d");
  glWindowPos2dv = (PFNGLWINDOWPOS2DVPROC)glfwGetProcAddress("glWindowPos2dv");
  glWindowPos2f = (PFNGLWINDOWPOS2FPROC)glfwGetProcAddress("glWindowPos2f");
  glWindowPos2fv = (PFNGLWINDOWPOS2FVPROC)glfwGetProcAddress("glWindowPos2fv");
  glWindowPos2i = (PFNGLWINDOWPOS2IPROC)glfwGetProcAddress("glWindowPos2i");
  glWindowPos2iv = (PFNGLWINDOWPOS2IVPROC)glfwGetProcAddress("glWindowPos2iv");
  glWindowPos2s = (PFNGLWINDOWPOS2SPROC)glfwGetProcAddress("glWindowPos2s");
  glWindowPos2sv = (PFNGLWINDOWPOS2SVPROC)glfwGetProcAddress("glWindowPos2sv");
  glWindowPos3d = (PFNGLWINDOWPOS3DPROC)glfwGetProcAddress("glWindowPos3d");
  glWindowPos3dv = (PFNGLWINDOWPOS3DVPROC)glfwGetProcAddress("glWindowPos3dv");
  glWindowPos3f = (PFNGLWINDOWPOS3FPROC)glfwGetProcAddress("glWindowPos3f");
  glWindowPos3fv = (PFNGLWINDOWPOS3FVPROC)glfwGetProcAddress("glWindowPos3fv");
  glWindowPos3i = (PFNGLWINDOWPOS3IPROC)glfwGetProcAddress("glWindowPos3i");
  glWindowPos3iv = (PFNGLWINDOWPOS3IVPROC)glfwGetProcAddress("glWindowPos3iv");
  glWindowPos3s = (PFNGLWINDOWPOS3SPROC)glfwGetProcAddress("glWindowPos3s");
  glWindowPos3sv = (PFNGLWINDOWPOS3SVPROC)glfwGetProcAddress("glWindowPos3sv");
  glGenQueries = (PFNGLGENQUERIESPROC)glfwGetProcAddress("glGenQueries");
  glDeleteQueries = (PFNGLDELETEQUERIESPROC)glfwGetProcAddress("glDeleteQueries");
  glIsQuery = (PFNGLISQUERYPROC)glfwGetProcAddress("glIsQuery");
  glBeginQuery = (PFNGLBEGINQUERYPROC)glfwGetProcAddress("glBeginQuery");
  glEndQuery = (PFNGLENDQUERYPROC)glfwGetProcAddress("glEndQuery");
  glGetQueryiv = (PFNGLGETQUERYIVPROC)glfwGetProcAddress("glGetQueryiv");
  glGetQueryObjectiv = (PFNGLGETQUERYOBJECTIVPROC)glfwGetProcAddress("glGetQueryObjectiv");
  glGetQueryObjectuiv = (PFNGLGETQUERYOBJECTUIVPROC)glfwGetProcAddress("glGetQueryObjectuiv");
  glBindBuffer = (PFNGLBINDBUFFERPROC)glfwGetProcAddress("glBindBuffer");
  glDeleteBuffers = (PFNGLDELETEBUFFERSPROC)glfwGetProcAddress("glDeleteBuffers");
  glGenBuffers = (PFNGLGENBUFFERSPROC)glfwGetProcAddress("glGenBuffers");
  glIsBuffer = (PFNGLISBUFFERPROC)glfwGetProcAddress("glIsBuffer");
  glBufferData = (PFNGLBUFFERDATAPROC)glfwGetProcAddress("glBufferData");
  glBufferSubData = (PFNGLBUFFERSUBDATAPROC)glfwGetProcAddress("glBufferSubData");
  glGetBufferSubData = (PFNGLGETBUFFERSUBDATAPROC)glfwGetProcAddress("glGetBufferSubData");
  glMapBuffer = (PFNGLMAPBUFFERPROC)glfwGetProcAddress("glMapBuffer");
  glUnmapBuffer = (PFNGLUNMAPBUFFERPROC)glfwGetProcAddress("glUnmapBuffer");
  glGetBufferParameteriv = (PFNGLGETBUFFERPARAMETERIVPROC)glfwGetProcAddress("glGetBufferParameteriv");
  glGetBufferPointerv = (PFNGLGETBUFFERPOINTERVPROC)glfwGetProcAddress("glGetBufferPointerv");
  glBlendEquationSeparate = (PFNGLBLENDEQUATIONSEPARATEPROC)glfwGetProcAddress("glBlendEquationSeparate");
  glDrawBuffers = (PFNGLDRAWBUFFERSPROC)glfwGetProcAddress("glDrawBuffers");
  glStencilOpSeparate = (PFNGLSTENCILOPSEPARATEPROC)glfwGetProcAddress("glStencilOpSeparate");
  glStencilFuncSeparate = (PFNGLSTENCILFUNCSEPARATEPROC)glfwGetProcAddress("glStencilFuncSeparate");
  glStencilMaskSeparate = (PFNGLSTENCILMASKSEPARATEPROC)glfwGetProcAddress("glStencilMaskSeparate");
  glAttachShader = (PFNGLATTACHSHADERPROC)glfwGetProcAddress("glAttachShader");
  glBindAttribLocation = (PFNGLBINDATTRIBLOCATIONPROC)glfwGetProcAddress("glBindAttribLocation");
  glCompileShader = (PFNGLCOMPILESHADERPROC)glfwGetProcAddress("glCompileShader");
  glCreateProgram = (PFNGLCREATEPROGRAMPROC)glfwGetProcAddress("glCreateProgram");
  glCreateShader = (PFNGLCREATESHADERPROC)glfwGetProcAddress("glCreateShader");
  glDeleteProgram = (PFNGLDELETEPROGRAMPROC)glfwGetProcAddress("glDeleteProgram");
  glDeleteShader = (PFNGLDELETESHADERPROC)glfwGetProcAddress("glDeleteShader");
  glDetachShader = (PFNGLDETACHSHADERPROC)glfwGetProcAddress("glDetachShader");
  glDisableVertexAttribArray = (PFNGLDISABLEVERTEXATTRIBARRAYPROC)glfwGetProcAddress("glDisableVertexAttribArray");
  glEnableVertexAttribArray = (PFNGLENABLEVERTEXATTRIBARRAYPROC)glfwGetProcAddress("glEnableVertexAttribArray");
  glGetActiveAttrib = (PFNGLGETACTIVEATTRIBPROC)glfwGetProcAddress("glGetActiveAttrib");
  glGetActiveUniform = (PFNGLGETACTIVEUNIFORMPROC)glfwGetProcAddress("glGetActiveUniform");
  glGetAttachedShaders = (PFNGLGETATTACHEDSHADERSPROC)glfwGetProcAddress("glGetAttachedShaders");
  glGetAttribLocation = (PFNGLGETATTRIBLOCATIONPROC)glfwGetProcAddress("glGetAttribLocation");
  glGetProgramiv = (PFNGLGETPROGRAMIVPROC)glfwGetProcAddress("glGetProgramiv");
  glGetProgramInfoLog = (PFNGLGETPROGRAMINFOLOGPROC)glfwGetProcAddress("glGetProgramInfoLog");
  glGetShaderiv = (PFNGLGETSHADERIVPROC)glfwGetProcAddress("glGetShaderiv");
  glGetShaderInfoLog = (PFNGLGETSHADERINFOLOGPROC)glfwGetProcAddress("glGetShaderInfoLog");
  glGetShaderSource = (PFNGLGETSHADERSOURCEPROC)glfwGetProcAddress("glGetShaderSource");
  glGetUniformLocation = (PFNGLGETUNIFORMLOCATIONPROC)glfwGetProcAddress("glGetUniformLocation");
  glGetUniformfv = (PFNGLGETUNIFORMFVPROC)glfwGetProcAddress("glGetUniformfv");
  glGetUniformiv = (PFNGLGETUNIFORMIVPROC)glfwGetProcAddress("glGetUniformiv");
  glGetVertexAttribdv = (PFNGLGETVERTEXATTRIBDVPROC)glfwGetProcAddress("glGetVertexAttribdv");
  glGetVertexAttribfv = (PFNGLGETVERTEXATTRIBFVPROC)glfwGetProcAddress("glGetVertexAttribfv");
  glGetVertexAttribiv = (PFNGLGETVERTEXATTRIBIVPROC)glfwGetProcAddress("glGetVertexAttribiv");
  glGetVertexAttribPointerv = (PFNGLGETVERTEXATTRIBPOINTERVPROC)glfwGetProcAddress("glGetVertexAttribPointerv");
  glIsProgram = (PFNGLISPROGRAMPROC)glfwGetProcAddress("glIsProgram");
  glIsShader = (PFNGLISSHADERPROC)glfwGetProcAddress("glIsShader");
  glLinkProgram = (PFNGLLINKPROGRAMPROC)glfwGetProcAddress("glLinkProgram");
  glShaderSource = (PFNGLSHADERSOURCEPROC)glfwGetProcAddress("glShaderSource");
  glUseProgram = (PFNGLUSEPROGRAMPROC)glfwGetProcAddress("glUseProgram");
  glUniform1f = (PFNGLUNIFORM1FPROC)glfwGetProcAddress("glUniform1f");
  glUniform2f = (PFNGLUNIFORM2FPROC)glfwGetProcAddress("glUniform2f");
  glUniform3f = (PFNGLUNIFORM3FPROC)glfwGetProcAddress("glUniform3f");
  glUniform4f = (PFNGLUNIFORM4FPROC)glfwGetProcAddress("glUniform4f");
  glUniform1i = (PFNGLUNIFORM1IPROC)glfwGetProcAddress("glUniform1i");
  glUniform2i = (PFNGLUNIFORM2IPROC)glfwGetProcAddress("glUniform2i");
  glUniform3i = (PFNGLUNIFORM3IPROC)glfwGetProcAddress("glUniform3i");
  glUniform4i = (PFNGLUNIFORM4IPROC)glfwGetProcAddress("glUniform4i");
  glUniform1fv = (PFNGLUNIFORM1FVPROC)glfwGetProcAddress("glUniform1fv");
  glUniform2fv = (PFNGLUNIFORM2FVPROC)glfwGetProcAddress("glUniform2fv");
  glUniform3fv = (PFNGLUNIFORM3FVPROC)glfwGetProcAddress("glUniform3fv");
  glUniform4fv = (PFNGLUNIFORM4FVPROC)glfwGetProcAddress("glUniform4fv");
  glUniform1iv = (PFNGLUNIFORM1IVPROC)glfwGetProcAddress("glUniform1iv");
  glUniform2iv = (PFNGLUNIFORM2IVPROC)glfwGetProcAddress("glUniform2iv");
  glUniform3iv = (PFNGLUNIFORM3IVPROC)glfwGetProcAddress("glUniform3iv");
  glUniform4iv = (PFNGLUNIFORM4IVPROC)glfwGetProcAddress("glUniform4iv");
  glUniformMatrix2fv = (PFNGLUNIFORMMATRIX2FVPROC)glfwGetProcAddress("glUniformMatrix2fv");
  glUniformMatrix3fv = (PFNGLUNIFORMMATRIX3FVPROC)glfwGetProcAddress("glUniformMatrix3fv");
  glUniformMatrix4fv = (PFNGLUNIFORMMATRIX4FVPROC)glfwGetProcAddress("glUniformMatrix4fv");
  glValidateProgram = (PFNGLVALIDATEPROGRAMPROC)glfwGetProcAddress("glValidateProgram");
  glVertexAttrib1d = (PFNGLVERTEXATTRIB1DPROC)glfwGetProcAddress("glVertexAttrib1d");
  glVertexAttrib1dv = (PFNGLVERTEXATTRIB1DVPROC)glfwGetProcAddress("glVertexAttrib1dv");
  glVertexAttrib1f = (PFNGLVERTEXATTRIB1FPROC)glfwGetProcAddress("glVertexAttrib1f");
  glVertexAttrib1fv = (PFNGLVERTEXATTRIB1FVPROC)glfwGetProcAddress("glVertexAttrib1fv");
  glVertexAttrib1s = (PFNGLVERTEXATTRIB1SPROC)glfwGetProcAddress("glVertexAttrib1s");
  glVertexAttrib1sv = (PFNGLVERTEXATTRIB1SVPROC)glfwGetProcAddress("glVertexAttrib1sv");
  glVertexAttrib2d = (PFNGLVERTEXATTRIB2DPROC)glfwGetProcAddress("glVertexAttrib2d");
  glVertexAttrib2dv = (PFNGLVERTEXATTRIB2DVPROC)glfwGetProcAddress("glVertexAttrib2dv");
  glVertexAttrib2f = (PFNGLVERTEXATTRIB2FPROC)glfwGetProcAddress("glVertexAttrib2f");
  glVertexAttrib2fv = (PFNGLVERTEXATTRIB2FVPROC)glfwGetProcAddress("glVertexAttrib2fv");
  glVertexAttrib2s = (PFNGLVERTEXATTRIB2SPROC)glfwGetProcAddress("glVertexAttrib2s");
  glVertexAttrib2sv = (PFNGLVERTEXATTRIB2SVPROC)glfwGetProcAddress("glVertexAttrib2sv");
  glVertexAttrib3d = (PFNGLVERTEXATTRIB3DPROC)glfwGetProcAddress("glVertexAttrib3d");
  glVertexAttrib3dv = (PFNGLVERTEXATTRIB3DVPROC)glfwGetProcAddress("glVertexAttrib3dv");
  glVertexAttrib3f = (PFNGLVERTEXATTRIB3FPROC)glfwGetProcAddress("glVertexAttrib3f");
  glVertexAttrib3fv = (PFNGLVERTEXATTRIB3FVPROC)glfwGetProcAddress("glVertexAttrib3fv");
  glVertexAttrib3s = (PFNGLVERTEXATTRIB3SPROC)glfwGetProcAddress("glVertexAttrib3s");
  glVertexAttrib3sv = (PFNGLVERTEXATTRIB3SVPROC)glfwGetProcAddress("glVertexAttrib3sv");
  glVertexAttrib4Nbv = (PFNGLVERTEXATTRIB4NBVPROC)glfwGetProcAddress("glVertexAttrib4Nbv");
  glVertexAttrib4Niv = (PFNGLVERTEXATTRIB4NIVPROC)glfwGetProcAddress("glVertexAttrib4Niv");
  glVertexAttrib4Nsv = (PFNGLVERTEXATTRIB4NSVPROC)glfwGetProcAddress("glVertexAttrib4Nsv");
  glVertexAttrib4Nub = (PFNGLVERTEXATTRIB4NUBPROC)glfwGetProcAddress("glVertexAttrib4Nub");
  glVertexAttrib4Nubv = (PFNGLVERTEXATTRIB4NUBVPROC)glfwGetProcAddress("glVertexAttrib4Nubv");
  glVertexAttrib4Nuiv = (PFNGLVERTEXATTRIB4NUIVPROC)glfwGetProcAddress("glVertexAttrib4Nuiv");
  glVertexAttrib4Nusv = (PFNGLVERTEXATTRIB4NUSVPROC)glfwGetProcAddress("glVertexAttrib4Nusv");
  glVertexAttrib4bv = (PFNGLVERTEXATTRIB4BVPROC)glfwGetProcAddress("glVertexAttrib4bv");
  glVertexAttrib4d = (PFNGLVERTEXATTRIB4DPROC)glfwGetProcAddress("glVertexAttrib4d");
  glVertexAttrib4dv = (PFNGLVERTEXATTRIB4DVPROC)glfwGetProcAddress("glVertexAttrib4dv");
  glVertexAttrib4f = (PFNGLVERTEXATTRIB4FPROC)glfwGetProcAddress("glVertexAttrib4f");
  glVertexAttrib4fv = (PFNGLVERTEXATTRIB4FVPROC)glfwGetProcAddress("glVertexAttrib4fv");
  glVertexAttrib4iv = (PFNGLVERTEXATTRIB4IVPROC)glfwGetProcAddress("glVertexAttrib4iv");
  glVertexAttrib4s = (PFNGLVERTEXATTRIB4SPROC)glfwGetProcAddress("glVertexAttrib4s");
  glVertexAttrib4sv = (PFNGLVERTEXATTRIB4SVPROC)glfwGetProcAddress("glVertexAttrib4sv");
  glVertexAttrib4ubv = (PFNGLVERTEXATTRIB4UBVPROC)glfwGetProcAddress("glVertexAttrib4ubv");
  glVertexAttrib4uiv = (PFNGLVERTEXATTRIB4UIVPROC)glfwGetProcAddress("glVertexAttrib4uiv");
  glVertexAttrib4usv = (PFNGLVERTEXATTRIB4USVPROC)glfwGetProcAddress("glVertexAttrib4usv");
  glVertexAttribPointer = (PFNGLVERTEXATTRIBPOINTERPROC)glfwGetProcAddress("glVertexAttribPointer");
  glUniformMatrix2x3fv = (PFNGLUNIFORMMATRIX2X3FVPROC)glfwGetProcAddress("glUniformMatrix2x3fv");
  glUniformMatrix3x2fv = (PFNGLUNIFORMMATRIX3X2FVPROC)glfwGetProcAddress("glUniformMatrix3x2fv");
  glUniformMatrix2x4fv = (PFNGLUNIFORMMATRIX2X4FVPROC)glfwGetProcAddress("glUniformMatrix2x4fv");
  glUniformMatrix4x2fv = (PFNGLUNIFORMMATRIX4X2FVPROC)glfwGetProcAddress("glUniformMatrix4x2fv");
  glUniformMatrix3x4fv = (PFNGLUNIFORMMATRIX3X4FVPROC)glfwGetProcAddress("glUniformMatrix3x4fv");
  glUniformMatrix4x3fv = (PFNGLUNIFORMMATRIX4X3FVPROC)glfwGetProcAddress("glUniformMatrix4x3fv");
  glColorMaski = (PFNGLCOLORMASKIPROC)glfwGetProcAddress("glColorMaski");
  glGetBooleani_v = (PFNGLGETBOOLEANI_VPROC)glfwGetProcAddress("glGetBooleani_v");
  glGetIntegeri_v = (PFNGLGETINTEGERI_VPROC)glfwGetProcAddress("glGetIntegeri_v");
  glEnablei = (PFNGLENABLEIPROC)glfwGetProcAddress("glEnablei");
  glDisablei = (PFNGLDISABLEIPROC)glfwGetProcAddress("glDisablei");
  glIsEnabledi = (PFNGLISENABLEDIPROC)glfwGetProcAddress("glIsEnabledi");
  glBeginTransformFeedback = (PFNGLBEGINTRANSFORMFEEDBACKPROC)glfwGetProcAddress("glBeginTransformFeedback");
  glEndTransformFeedback = (PFNGLENDTRANSFORMFEEDBACKPROC)glfwGetProcAddress("glEndTransformFeedback");
  glBindBufferRange = (PFNGLBINDBUFFERRANGEPROC)glfwGetProcAddress("glBindBufferRange");
  glBindBufferBase = (PFNGLBINDBUFFERBASEPROC)glfwGetProcAddress("glBindBufferBase");
  glTransformFeedbackVaryings = (PFNGLTRANSFORMFEEDBACKVARYINGSPROC)glfwGetProcAddress("glTransformFeedbackVaryings");
  glGetTransformFeedbackVarying = (PFNGLGETTRANSFORMFEEDBACKVARYINGPROC)glfwGetProcAddress("glGetTransformFeedbackVarying");
  glClampColor = (PFNGLCLAMPCOLORPROC)glfwGetProcAddress("glClampColor");
  glBeginConditionalRender = (PFNGLBEGINCONDITIONALRENDERPROC)glfwGetProcAddress("glBeginConditionalRender");
  glEndConditionalRender = (PFNGLENDCONDITIONALRENDERPROC)glfwGetProcAddress("glEndConditionalRender");
  glVertexAttribIPointer = (PFNGLVERTEXATTRIBIPOINTERPROC)glfwGetProcAddress("glVertexAttribIPointer");
  glGetVertexAttribIiv = (PFNGLGETVERTEXATTRIBIIVPROC)glfwGetProcAddress("glGetVertexAttribIiv");
  glGetVertexAttribIuiv = (PFNGLGETVERTEXATTRIBIUIVPROC)glfwGetProcAddress("glGetVertexAttribIuiv");
  glVertexAttribI1i = (PFNGLVERTEXATTRIBI1IPROC)glfwGetProcAddress("glVertexAttribI1i");
  glVertexAttribI2i = (PFNGLVERTEXATTRIBI2IPROC)glfwGetProcAddress("glVertexAttribI2i");
  glVertexAttribI3i = (PFNGLVERTEXATTRIBI3IPROC)glfwGetProcAddress("glVertexAttribI3i");
  glVertexAttribI4i = (PFNGLVERTEXATTRIBI4IPROC)glfwGetProcAddress("glVertexAttribI4i");
  glVertexAttribI1ui = (PFNGLVERTEXATTRIBI1UIPROC)glfwGetProcAddress("glVertexAttribI1ui");
  glVertexAttribI2ui = (PFNGLVERTEXATTRIBI2UIPROC)glfwGetProcAddress("glVertexAttribI2ui");
  glVertexAttribI3ui = (PFNGLVERTEXATTRIBI3UIPROC)glfwGetProcAddress("glVertexAttribI3ui");
  glVertexAttribI4ui = (PFNGLVERTEXATTRIBI4UIPROC)glfwGetProcAddress("glVertexAttribI4ui");
  glVertexAttribI1iv = (PFNGLVERTEXATTRIBI1IVPROC)glfwGetProcAddress("glVertexAttribI1iv");
  glVertexAttribI2iv = (PFNGLVERTEXATTRIBI2IVPROC)glfwGetProcAddress("glVertexAttribI2iv");
  glVertexAttribI3iv = (PFNGLVERTEXATTRIBI3IVPROC)glfwGetProcAddress("glVertexAttribI3iv");
  glVertexAttribI4iv = (PFNGLVERTEXATTRIBI4IVPROC)glfwGetProcAddress("glVertexAttribI4iv");
  glVertexAttribI1uiv = (PFNGLVERTEXATTRIBI1UIVPROC)glfwGetProcAddress("glVertexAttribI1uiv");
  glVertexAttribI2uiv = (PFNGLVERTEXATTRIBI2UIVPROC)glfwGetProcAddress("glVertexAttribI2uiv");
  glVertexAttribI3uiv = (PFNGLVERTEXATTRIBI3UIVPROC)glfwGetProcAddress("glVertexAttribI3uiv");
  glVertexAttribI4uiv = (PFNGLVERTEXATTRIBI4UIVPROC)glfwGetProcAddress("glVertexAttribI4uiv");
  glVertexAttribI4bv = (PFNGLVERTEXATTRIBI4BVPROC)glfwGetProcAddress("glVertexAttribI4bv");
  glVertexAttribI4sv = (PFNGLVERTEXATTRIBI4SVPROC)glfwGetProcAddress("glVertexAttribI4sv");
  glVertexAttribI4ubv = (PFNGLVERTEXATTRIBI4UBVPROC)glfwGetProcAddress("glVertexAttribI4ubv");
  glVertexAttribI4usv = (PFNGLVERTEXATTRIBI4USVPROC)glfwGetProcAddress("glVertexAttribI4usv");
  glGetUniformuiv = (PFNGLGETUNIFORMUIVPROC)glfwGetProcAddress("glGetUniformuiv");
  glBindFragDataLocation = (PFNGLBINDFRAGDATALOCATIONPROC)glfwGetProcAddress("glBindFragDataLocation");
  glGetFragDataLocation = (PFNGLGETFRAGDATALOCATIONPROC)glfwGetProcAddress("glGetFragDataLocation");
  glUniform1ui = (PFNGLUNIFORM1UIPROC)glfwGetProcAddress("glUniform1ui");
  glUniform2ui = (PFNGLUNIFORM2UIPROC)glfwGetProcAddress("glUniform2ui");
  glUniform3ui = (PFNGLUNIFORM3UIPROC)glfwGetProcAddress("glUniform3ui");
  glUniform4ui = (PFNGLUNIFORM4UIPROC)glfwGetProcAddress("glUniform4ui");
  glUniform1uiv = (PFNGLUNIFORM1UIVPROC)glfwGetProcAddress("glUniform1uiv");
  glUniform2uiv = (PFNGLUNIFORM2UIVPROC)glfwGetProcAddress("glUniform2uiv");
  glUniform3uiv = (PFNGLUNIFORM3UIVPROC)glfwGetProcAddress("glUniform3uiv");
  glUniform4uiv = (PFNGLUNIFORM4UIVPROC)glfwGetProcAddress("glUniform4uiv");
  glTexParameterIiv = (PFNGLTEXPARAMETERIIVPROC)glfwGetProcAddress("glTexParameterIiv");
  glTexParameterIuiv = (PFNGLTEXPARAMETERIUIVPROC)glfwGetProcAddress("glTexParameterIuiv");
  glGetTexParameterIiv = (PFNGLGETTEXPARAMETERIIVPROC)glfwGetProcAddress("glGetTexParameterIiv");
  glGetTexParameterIuiv = (PFNGLGETTEXPARAMETERIUIVPROC)glfwGetProcAddress("glGetTexParameterIuiv");
  glClearBufferiv = (PFNGLCLEARBUFFERIVPROC)glfwGetProcAddress("glClearBufferiv");
  glClearBufferuiv = (PFNGLCLEARBUFFERUIVPROC)glfwGetProcAddress("glClearBufferuiv");
  glClearBufferfv = (PFNGLCLEARBUFFERFVPROC)glfwGetProcAddress("glClearBufferfv");
  glClearBufferfi = (PFNGLCLEARBUFFERFIPROC)glfwGetProcAddress("glClearBufferfi");
  glGetStringi = (PFNGLGETSTRINGIPROC)glfwGetProcAddress("glGetStringi");
  glDrawArraysInstanced = (PFNGLDRAWARRAYSINSTANCEDPROC)glfwGetProcAddress("glDrawArraysInstanced");
  glDrawElementsInstanced = (PFNGLDRAWELEMENTSINSTANCEDPROC)glfwGetProcAddress("glDrawElementsInstanced");
  glTexBuffer = (PFNGLTEXBUFFERPROC)glfwGetProcAddress("glTexBuffer");
  glPrimitiveRestartIndex = (PFNGLPRIMITIVERESTARTINDEXPROC)glfwGetProcAddress("glPrimitiveRestartIndex");
  glGetInteger64i_v = (PFNGLGETINTEGER64I_VPROC)glfwGetProcAddress("glGetInteger64i_v");
  glGetBufferParameteri64v = (PFNGLGETBUFFERPARAMETERI64VPROC)glfwGetProcAddress("glGetBufferParameteri64v");
  glFramebufferTexture = (PFNGLFRAMEBUFFERTEXTUREPROC)glfwGetProcAddress("glFramebufferTexture");
  glVertexAttribDivisor = (PFNGLVERTEXATTRIBDIVISORPROC)glfwGetProcAddress("glVertexAttribDivisor");
  glMinSampleShading = (PFNGLMINSAMPLESHADINGPROC)glfwGetProcAddress("glMinSampleShading");
  glBlendEquationi = (PFNGLBLENDEQUATIONIPROC)glfwGetProcAddress("glBlendEquationi");
  glBlendEquationSeparatei = (PFNGLBLENDEQUATIONSEPARATEIPROC)glfwGetProcAddress("glBlendEquationSeparatei");
  glBlendFunci = (PFNGLBLENDFUNCIPROC)glfwGetProcAddress("glBlendFunci");
  glBlendFuncSeparatei = (PFNGLBLENDFUNCSEPARATEIPROC)glfwGetProcAddress("glBlendFuncSeparatei");
  glIsRenderbuffer = (PFNGLISRENDERBUFFERPROC)glfwGetProcAddress("glIsRenderbuffer");
  glBindRenderbuffer = (PFNGLBINDRENDERBUFFERPROC)glfwGetProcAddress("glBindRenderbuffer");
  glDeleteRenderbuffers = (PFNGLDELETERENDERBUFFERSPROC)glfwGetProcAddress("glDeleteRenderbuffers");
  glGenRenderbuffers = (PFNGLGENRENDERBUFFERSPROC)glfwGetProcAddress("glGenRenderbuffers");
  glRenderbufferStorage = (PFNGLRENDERBUFFERSTORAGEPROC)glfwGetProcAddress("glRenderbufferStorage");
  glGetRenderbufferParameteriv = (PFNGLGETRENDERBUFFERPARAMETERIVPROC)glfwGetProcAddress("glGetRenderbufferParameteriv");
  glIsFramebuffer = (PFNGLISFRAMEBUFFERPROC)glfwGetProcAddress("glIsFramebuffer");
  glBindFramebuffer = (PFNGLBINDFRAMEBUFFERPROC)glfwGetProcAddress("glBindFramebuffer");
  glDeleteFramebuffers = (PFNGLDELETEFRAMEBUFFERSPROC)glfwGetProcAddress("glDeleteFramebuffers");
  glGenFramebuffers = (PFNGLGENFRAMEBUFFERSPROC)glfwGetProcAddress("glGenFramebuffers");
  glCheckFramebufferStatus = (PFNGLCHECKFRAMEBUFFERSTATUSPROC)glfwGetProcAddress("glCheckFramebufferStatus");
  glFramebufferTexture1D = (PFNGLFRAMEBUFFERTEXTURE1DPROC)glfwGetProcAddress("glFramebufferTexture1D");
  glFramebufferTexture2D = (PFNGLFRAMEBUFFERTEXTURE2DPROC)glfwGetProcAddress("glFramebufferTexture2D");
  glFramebufferTexture3D = (PFNGLFRAMEBUFFERTEXTURE3DPROC)glfwGetProcAddress("glFramebufferTexture3D");
  glFramebufferRenderbuffer = (PFNGLFRAMEBUFFERRENDERBUFFERPROC)glfwGetProcAddress("glFramebufferRenderbuffer");
  glGetFramebufferAttachmentParameteriv = (PFNGLGETFRAMEBUFFERATTACHMENTPARAMETERIVPROC)glfwGetProcAddress("glGetFramebufferAttachmentParameteriv");
  glGenerateMipmap = (PFNGLGENERATEMIPMAPPROC)glfwGetProcAddress("glGenerateMipmap");
  glBlitFramebuffer = (PFNGLBLITFRAMEBUFFERPROC)glfwGetProcAddress("glBlitFramebuffer");
  glRenderbufferStorageMultisample = (PFNGLRENDERBUFFERSTORAGEMULTISAMPLEPROC)glfwGetProcAddress("glRenderbufferStorageMultisample");
  glFramebufferTextureLayer = (PFNGLFRAMEBUFFERTEXTURELAYERPROC)glfwGetProcAddress("glFramebufferTextureLayer");
  glMapBufferRange = (PFNGLMAPBUFFERRANGEPROC)glfwGetProcAddress("glMapBufferRange");
  glFlushMappedBufferRange = (PFNGLFLUSHMAPPEDBUFFERRANGEPROC)glfwGetProcAddress("glFlushMappedBufferRange");
  glBindVertexArray = (PFNGLBINDVERTEXARRAYPROC)glfwGetProcAddress("glBindVertexArray");
  glDeleteVertexArrays = (PFNGLDELETEVERTEXARRAYSPROC)glfwGetProcAddress("glDeleteVertexArrays");
  glGenVertexArrays = (PFNGLGENVERTEXARRAYSPROC)glfwGetProcAddress("glGenVertexArrays");
  glIsVertexArray = (PFNGLISVERTEXARRAYPROC)glfwGetProcAddress("glIsVertexArray");
  glGetUniformIndices = (PFNGLGETUNIFORMINDICESPROC)glfwGetProcAddress("glGetUniformIndices");
  glGetActiveUniformsiv = (PFNGLGETACTIVEUNIFORMSIVPROC)glfwGetProcAddress("glGetActiveUniformsiv");
  glGetActiveUniformName = (PFNGLGETACTIVEUNIFORMNAMEPROC)glfwGetProcAddress("glGetActiveUniformName");
  glGetUniformBlockIndex = (PFNGLGETUNIFORMBLOCKINDEXPROC)glfwGetProcAddress("glGetUniformBlockIndex");
  glGetActiveUniformBlockiv = (PFNGLGETACTIVEUNIFORMBLOCKIVPROC)glfwGetProcAddress("glGetActiveUniformBlockiv");
  glGetActiveUniformBlockName = (PFNGLGETACTIVEUNIFORMBLOCKNAMEPROC)glfwGetProcAddress("glGetActiveUniformBlockName");
  glUniformBlockBinding = (PFNGLUNIFORMBLOCKBINDINGPROC)glfwGetProcAddress("glUniformBlockBinding");
  glCopyBufferSubData = (PFNGLCOPYBUFFERSUBDATAPROC)glfwGetProcAddress("glCopyBufferSubData");
  glDrawElementsBaseVertex = (PFNGLDRAWELEMENTSBASEVERTEXPROC)glfwGetProcAddress("glDrawElementsBaseVertex");
  glDrawRangeElementsBaseVertex = (PFNGLDRAWRANGEELEMENTSBASEVERTEXPROC)glfwGetProcAddress("glDrawRangeElementsBaseVertex");
  glDrawElementsInstancedBaseVertex = (PFNGLDRAWELEMENTSINSTANCEDBASEVERTEXPROC)glfwGetProcAddress("glDrawElementsInstancedBaseVertex");
  glMultiDrawElementsBaseVertex = (PFNGLMULTIDRAWELEMENTSBASEVERTEXPROC)glfwGetProcAddress("glMultiDrawElementsBaseVertex");
  glProvokingVertex = (PFNGLPROVOKINGVERTEXPROC)glfwGetProcAddress("glProvokingVertex");
  glFenceSync = (PFNGLFENCESYNCPROC)glfwGetProcAddress("glFenceSync");
  glIsSync = (PFNGLISSYNCPROC)glfwGetProcAddress("glIsSync");
  glDeleteSync = (PFNGLDELETESYNCPROC)glfwGetProcAddress("glDeleteSync");
  glClientWaitSync = (PFNGLCLIENTWAITSYNCPROC)glfwGetProcAddress("glClientWaitSync");
  glWaitSync = (PFNGLWAITSYNCPROC)glfwGetProcAddress("glWaitSync");
  glGetInteger64v = (PFNGLGETINTEGER64VPROC)glfwGetProcAddress("glGetInteger64v");
  glGetSynciv = (PFNGLGETSYNCIVPROC)glfwGetProcAddress("glGetSynciv");
  glTexImage2DMultisample = (PFNGLTEXIMAGE2DMULTISAMPLEPROC)glfwGetProcAddress("glTexImage2DMultisample");
  glTexImage3DMultisample = (PFNGLTEXIMAGE3DMULTISAMPLEPROC)glfwGetProcAddress("glTexImage3DMultisample");
  glGetMultisamplefv = (PFNGLGETMULTISAMPLEFVPROC)glfwGetProcAddress("glGetMultisamplefv");
  glSampleMaski = (PFNGLSAMPLEMASKIPROC)glfwGetProcAddress("glSampleMaski");
  glBindFragDataLocationIndexed = (PFNGLBINDFRAGDATALOCATIONINDEXEDPROC)glfwGetProcAddress("glBindFragDataLocationIndexed");
  glGetFragDataIndex = (PFNGLGETFRAGDATAINDEXPROC)glfwGetProcAddress("glGetFragDataIndex");
  glGenSamplers = (PFNGLGENSAMPLERSPROC)glfwGetProcAddress("glGenSamplers");
  glDeleteSamplers = (PFNGLDELETESAMPLERSPROC)glfwGetProcAddress("glDeleteSamplers");
  glIsSampler = (PFNGLISSAMPLERPROC)glfwGetProcAddress("glIsSampler");
  glBindSampler = (PFNGLBINDSAMPLERPROC)glfwGetProcAddress("glBindSampler");
  glSamplerParameteri = (PFNGLSAMPLERPARAMETERIPROC)glfwGetProcAddress("glSamplerParameteri");
  glSamplerParameteriv = (PFNGLSAMPLERPARAMETERIVPROC)glfwGetProcAddress("glSamplerParameteriv");
  glSamplerParameterf = (PFNGLSAMPLERPARAMETERFPROC)glfwGetProcAddress("glSamplerParameterf");
  glSamplerParameterfv = (PFNGLSAMPLERPARAMETERFVPROC)glfwGetProcAddress("glSamplerParameterfv");
  glSamplerParameterIiv = (PFNGLSAMPLERPARAMETERIIVPROC)glfwGetProcAddress("glSamplerParameterIiv");
  glSamplerParameterIuiv = (PFNGLSAMPLERPARAMETERIUIVPROC)glfwGetProcAddress("glSamplerParameterIuiv");
  glGetSamplerParameteriv = (PFNGLGETSAMPLERPARAMETERIVPROC)glfwGetProcAddress("glGetSamplerParameteriv");
  glGetSamplerParameterIiv = (PFNGLGETSAMPLERPARAMETERIIVPROC)glfwGetProcAddress("glGetSamplerParameterIiv");
  glGetSamplerParameterfv = (PFNGLGETSAMPLERPARAMETERFVPROC)glfwGetProcAddress("glGetSamplerParameterfv");
  glGetSamplerParameterIuiv = (PFNGLGETSAMPLERPARAMETERIUIVPROC)glfwGetProcAddress("glGetSamplerParameterIuiv");
  glQueryCounter = (PFNGLQUERYCOUNTERPROC)glfwGetProcAddress("glQueryCounter");
  glGetQueryObjecti64v = (PFNGLGETQUERYOBJECTI64VPROC)glfwGetProcAddress("glGetQueryObjecti64v");
  glGetQueryObjectui64v = (PFNGLGETQUERYOBJECTUI64VPROC)glfwGetProcAddress("glGetQueryObjectui64v");
  glVertexP2ui = (PFNGLVERTEXP2UIPROC)glfwGetProcAddress("glVertexP2ui");
  glVertexP2uiv = (PFNGLVERTEXP2UIVPROC)glfwGetProcAddress("glVertexP2uiv");
  glVertexP3ui = (PFNGLVERTEXP3UIPROC)glfwGetProcAddress("glVertexP3ui");
  glVertexP3uiv = (PFNGLVERTEXP3UIVPROC)glfwGetProcAddress("glVertexP3uiv");
  glVertexP4ui = (PFNGLVERTEXP4UIPROC)glfwGetProcAddress("glVertexP4ui");
  glVertexP4uiv = (PFNGLVERTEXP4UIVPROC)glfwGetProcAddress("glVertexP4uiv");
  glTexCoordP1ui = (PFNGLTEXCOORDP1UIPROC)glfwGetProcAddress("glTexCoordP1ui");
  glTexCoordP1uiv = (PFNGLTEXCOORDP1UIVPROC)glfwGetProcAddress("glTexCoordP1uiv");
  glTexCoordP2ui = (PFNGLTEXCOORDP2UIPROC)glfwGetProcAddress("glTexCoordP2ui");
  glTexCoordP2uiv = (PFNGLTEXCOORDP2UIVPROC)glfwGetProcAddress("glTexCoordP2uiv");
  glTexCoordP3ui = (PFNGLTEXCOORDP3UIPROC)glfwGetProcAddress("glTexCoordP3ui");
  glTexCoordP3uiv = (PFNGLTEXCOORDP3UIVPROC)glfwGetProcAddress("glTexCoordP3uiv");
  glTexCoordP4ui = (PFNGLTEXCOORDP4UIPROC)glfwGetProcAddress("glTexCoordP4ui");
  glTexCoordP4uiv = (PFNGLTEXCOORDP4UIVPROC)glfwGetProcAddress("glTexCoordP4uiv");
  glMultiTexCoordP1ui = (PFNGLMULTITEXCOORDP1UIPROC)glfwGetProcAddress("glMultiTexCoordP1ui");
  glMultiTexCoordP1uiv = (PFNGLMULTITEXCOORDP1UIVPROC)glfwGetProcAddress("glMultiTexCoordP1uiv");
  glMultiTexCoordP2ui = (PFNGLMULTITEXCOORDP2UIPROC)glfwGetProcAddress("glMultiTexCoordP2ui");
  glMultiTexCoordP2uiv = (PFNGLMULTITEXCOORDP2UIVPROC)glfwGetProcAddress("glMultiTexCoordP2uiv");
  glMultiTexCoordP3ui = (PFNGLMULTITEXCOORDP3UIPROC)glfwGetProcAddress("glMultiTexCoordP3ui");
  glMultiTexCoordP3uiv = (PFNGLMULTITEXCOORDP3UIVPROC)glfwGetProcAddress("glMultiTexCoordP3uiv");
  glMultiTexCoordP4ui = (PFNGLMULTITEXCOORDP4UIPROC)glfwGetProcAddress("glMultiTexCoordP4ui");
  glMultiTexCoordP4uiv = (PFNGLMULTITEXCOORDP4UIVPROC)glfwGetProcAddress("glMultiTexCoordP4uiv");
  glNormalP3ui = (PFNGLNORMALP3UIPROC)glfwGetProcAddress("glNormalP3ui");
  glNormalP3uiv = (PFNGLNORMALP3UIVPROC)glfwGetProcAddress("glNormalP3uiv");
  glColorP3ui = (PFNGLCOLORP3UIPROC)glfwGetProcAddress("glColorP3ui");
  glColorP3uiv = (PFNGLCOLORP3UIVPROC)glfwGetProcAddress("glColorP3uiv");
  glColorP4ui = (PFNGLCOLORP4UIPROC)glfwGetProcAddress("glColorP4ui");
  glColorP4uiv = (PFNGLCOLORP4UIVPROC)glfwGetProcAddress("glColorP4uiv");
  glSecondaryColorP3ui = (PFNGLSECONDARYCOLORP3UIPROC)glfwGetProcAddress("glSecondaryColorP3ui");
  glSecondaryColorP3uiv = (PFNGLSECONDARYCOLORP3UIVPROC)glfwGetProcAddress("glSecondaryColorP3uiv");
  glVertexAttribP1ui = (PFNGLVERTEXATTRIBP1UIPROC)glfwGetProcAddress("glVertexAttribP1ui");
  glVertexAttribP1uiv = (PFNGLVERTEXATTRIBP1UIVPROC)glfwGetProcAddress("glVertexAttribP1uiv");
  glVertexAttribP2ui = (PFNGLVERTEXATTRIBP2UIPROC)glfwGetProcAddress("glVertexAttribP2ui");
  glVertexAttribP2uiv = (PFNGLVERTEXATTRIBP2UIVPROC)glfwGetProcAddress("glVertexAttribP2uiv");
  glVertexAttribP3ui = (PFNGLVERTEXATTRIBP3UIPROC)glfwGetProcAddress("glVertexAttribP3ui");
  glVertexAttribP3uiv = (PFNGLVERTEXATTRIBP3UIVPROC)glfwGetProcAddress("glVertexAttribP3uiv");
  glVertexAttribP4ui = (PFNGLVERTEXATTRIBP4UIPROC)glfwGetProcAddress("glVertexAttribP4ui");
  glVertexAttribP4uiv = (PFNGLVERTEXATTRIBP4UIVPROC)glfwGetProcAddress("glVertexAttribP4uiv");
  glDrawArraysIndirect = (PFNGLDRAWARRAYSINDIRECTPROC)glfwGetProcAddress("glDrawArraysIndirect");
  glDrawElementsIndirect = (PFNGLDRAWELEMENTSINDIRECTPROC)glfwGetProcAddress("glDrawElementsIndirect");
  glUniform1d = (PFNGLUNIFORM1DPROC)glfwGetProcAddress("glUniform1d");
  glUniform2d = (PFNGLUNIFORM2DPROC)glfwGetProcAddress("glUniform2d");
  glUniform3d = (PFNGLUNIFORM3DPROC)glfwGetProcAddress("glUniform3d");
  glUniform4d = (PFNGLUNIFORM4DPROC)glfwGetProcAddress("glUniform4d");
  glUniform1dv = (PFNGLUNIFORM1DVPROC)glfwGetProcAddress("glUniform1dv");
  glUniform2dv = (PFNGLUNIFORM2DVPROC)glfwGetProcAddress("glUniform2dv");
  glUniform3dv = (PFNGLUNIFORM3DVPROC)glfwGetProcAddress("glUniform3dv");
  glUniform4dv = (PFNGLUNIFORM4DVPROC)glfwGetProcAddress("glUniform4dv");
  glUniformMatrix2dv = (PFNGLUNIFORMMATRIX2DVPROC)glfwGetProcAddress("glUniformMatrix2dv");
  glUniformMatrix3dv = (PFNGLUNIFORMMATRIX3DVPROC)glfwGetProcAddress("glUniformMatrix3dv");
  glUniformMatrix4dv = (PFNGLUNIFORMMATRIX4DVPROC)glfwGetProcAddress("glUniformMatrix4dv");
  glUniformMatrix2x3dv = (PFNGLUNIFORMMATRIX2X3DVPROC)glfwGetProcAddress("glUniformMatrix2x3dv");
  glUniformMatrix2x4dv = (PFNGLUNIFORMMATRIX2X4DVPROC)glfwGetProcAddress("glUniformMatrix2x4dv");
  glUniformMatrix3x2dv = (PFNGLUNIFORMMATRIX3X2DVPROC)glfwGetProcAddress("glUniformMatrix3x2dv");
  glUniformMatrix3x4dv = (PFNGLUNIFORMMATRIX3X4DVPROC)glfwGetProcAddress("glUniformMatrix3x4dv");
  glUniformMatrix4x2dv = (PFNGLUNIFORMMATRIX4X2DVPROC)glfwGetProcAddress("glUniformMatrix4x2dv");
  glUniformMatrix4x3dv = (PFNGLUNIFORMMATRIX4X3DVPROC)glfwGetProcAddress("glUniformMatrix4x3dv");
  glGetUniformdv = (PFNGLGETUNIFORMDVPROC)glfwGetProcAddress("glGetUniformdv");
  glGetSubroutineUniformLocation = (PFNGLGETSUBROUTINEUNIFORMLOCATIONPROC)glfwGetProcAddress("glGetSubroutineUniformLocation");
  glGetSubroutineIndex = (PFNGLGETSUBROUTINEINDEXPROC)glfwGetProcAddress("glGetSubroutineIndex");
  glGetActiveSubroutineUniformiv = (PFNGLGETACTIVESUBROUTINEUNIFORMIVPROC)glfwGetProcAddress("glGetActiveSubroutineUniformiv");
  glGetActiveSubroutineUniformName = (PFNGLGETACTIVESUBROUTINEUNIFORMNAMEPROC)glfwGetProcAddress("glGetActiveSubroutineUniformName");
  glGetActiveSubroutineName = (PFNGLGETACTIVESUBROUTINENAMEPROC)glfwGetProcAddress("glGetActiveSubroutineName");
  glUniformSubroutinesuiv = (PFNGLUNIFORMSUBROUTINESUIVPROC)glfwGetProcAddress("glUniformSubroutinesuiv");
  glGetUniformSubroutineuiv = (PFNGLGETUNIFORMSUBROUTINEUIVPROC)glfwGetProcAddress("glGetUniformSubroutineuiv");
  glGetProgramStageiv = (PFNGLGETPROGRAMSTAGEIVPROC)glfwGetProcAddress("glGetProgramStageiv");
  glPatchParameteri = (PFNGLPATCHPARAMETERIPROC)glfwGetProcAddress("glPatchParameteri");
  glPatchParameterfv = (PFNGLPATCHPARAMETERFVPROC)glfwGetProcAddress("glPatchParameterfv");
  glBindTransformFeedback = (PFNGLBINDTRANSFORMFEEDBACKPROC)glfwGetProcAddress("glBindTransformFeedback");
  glDeleteTransformFeedbacks = (PFNGLDELETETRANSFORMFEEDBACKSPROC)glfwGetProcAddress("glDeleteTransformFeedbacks");
  glGenTransformFeedbacks = (PFNGLGENTRANSFORMFEEDBACKSPROC)glfwGetProcAddress("glGenTransformFeedbacks");
  glIsTransformFeedback = (PFNGLISTRANSFORMFEEDBACKPROC)glfwGetProcAddress("glIsTransformFeedback");
  glPauseTransformFeedback = (PFNGLPAUSETRANSFORMFEEDBACKPROC)glfwGetProcAddress("glPauseTransformFeedback");
  glResumeTransformFeedback = (PFNGLRESUMETRANSFORMFEEDBACKPROC)glfwGetProcAddress("glResumeTransformFeedback");
  glDrawTransformFeedback = (PFNGLDRAWTRANSFORMFEEDBACKPROC)glfwGetProcAddress("glDrawTransformFeedback");
  glDrawTransformFeedbackStream = (PFNGLDRAWTRANSFORMFEEDBACKSTREAMPROC)glfwGetProcAddress("glDrawTransformFeedbackStream");
  glBeginQueryIndexed = (PFNGLBEGINQUERYINDEXEDPROC)glfwGetProcAddress("glBeginQueryIndexed");
  glEndQueryIndexed = (PFNGLENDQUERYINDEXEDPROC)glfwGetProcAddress("glEndQueryIndexed");
  glGetQueryIndexediv = (PFNGLGETQUERYINDEXEDIVPROC)glfwGetProcAddress("glGetQueryIndexediv");
  glReleaseShaderCompiler = (PFNGLRELEASESHADERCOMPILERPROC)glfwGetProcAddress("glReleaseShaderCompiler");
  glShaderBinary = (PFNGLSHADERBINARYPROC)glfwGetProcAddress("glShaderBinary");
  glGetShaderPrecisionFormat = (PFNGLGETSHADERPRECISIONFORMATPROC)glfwGetProcAddress("glGetShaderPrecisionFormat");
  glDepthRangef = (PFNGLDEPTHRANGEFPROC)glfwGetProcAddress("glDepthRangef");
  glClearDepthf = (PFNGLCLEARDEPTHFPROC)glfwGetProcAddress("glClearDepthf");
  glGetProgramBinary = (PFNGLGETPROGRAMBINARYPROC)glfwGetProcAddress("glGetProgramBinary");
  glProgramBinary = (PFNGLPROGRAMBINARYPROC)glfwGetProcAddress("glProgramBinary");
  glProgramParameteri = (PFNGLPROGRAMPARAMETERIPROC)glfwGetProcAddress("glProgramParameteri");
  glUseProgramStages = (PFNGLUSEPROGRAMSTAGESPROC)glfwGetProcAddress("glUseProgramStages");
  glActiveShaderProgram = (PFNGLACTIVESHADERPROGRAMPROC)glfwGetProcAddress("glActiveShaderProgram");
  glCreateShaderProgramv = (PFNGLCREATESHADERPROGRAMVPROC)glfwGetProcAddress("glCreateShaderProgramv");
  glBindProgramPipeline = (PFNGLBINDPROGRAMPIPELINEPROC)glfwGetProcAddress("glBindProgramPipeline");
  glDeleteProgramPipelines = (PFNGLDELETEPROGRAMPIPELINESPROC)glfwGetProcAddress("glDeleteProgramPipelines");
  glGenProgramPipelines = (PFNGLGENPROGRAMPIPELINESPROC)glfwGetProcAddress("glGenProgramPipelines");
  glIsProgramPipeline = (PFNGLISPROGRAMPIPELINEPROC)glfwGetProcAddress("glIsProgramPipeline");
  glGetProgramPipelineiv = (PFNGLGETPROGRAMPIPELINEIVPROC)glfwGetProcAddress("glGetProgramPipelineiv");
  glProgramUniform1i = (PFNGLPROGRAMUNIFORM1IPROC)glfwGetProcAddress("glProgramUniform1i");
  glProgramUniform1iv = (PFNGLPROGRAMUNIFORM1IVPROC)glfwGetProcAddress("glProgramUniform1iv");
  glProgramUniform1f = (PFNGLPROGRAMUNIFORM1FPROC)glfwGetProcAddress("glProgramUniform1f");
  glProgramUniform1fv = (PFNGLPROGRAMUNIFORM1FVPROC)glfwGetProcAddress("glProgramUniform1fv");
  glProgramUniform1d = (PFNGLPROGRAMUNIFORM1DPROC)glfwGetProcAddress("glProgramUniform1d");
  glProgramUniform1dv = (PFNGLPROGRAMUNIFORM1DVPROC)glfwGetProcAddress("glProgramUniform1dv");
  glProgramUniform1ui = (PFNGLPROGRAMUNIFORM1UIPROC)glfwGetProcAddress("glProgramUniform1ui");
  glProgramUniform1uiv = (PFNGLPROGRAMUNIFORM1UIVPROC)glfwGetProcAddress("glProgramUniform1uiv");
  glProgramUniform2i = (PFNGLPROGRAMUNIFORM2IPROC)glfwGetProcAddress("glProgramUniform2i");
  glProgramUniform2iv = (PFNGLPROGRAMUNIFORM2IVPROC)glfwGetProcAddress("glProgramUniform2iv");
  glProgramUniform2f = (PFNGLPROGRAMUNIFORM2FPROC)glfwGetProcAddress("glProgramUniform2f");
  glProgramUniform2fv = (PFNGLPROGRAMUNIFORM2FVPROC)glfwGetProcAddress("glProgramUniform2fv");
  glProgramUniform2d = (PFNGLPROGRAMUNIFORM2DPROC)glfwGetProcAddress("glProgramUniform2d");
  glProgramUniform2dv = (PFNGLPROGRAMUNIFORM2DVPROC)glfwGetProcAddress("glProgramUniform2dv");
  glProgramUniform2ui = (PFNGLPROGRAMUNIFORM2UIPROC)glfwGetProcAddress("glProgramUniform2ui");
  glProgramUniform2uiv = (PFNGLPROGRAMUNIFORM2UIVPROC)glfwGetProcAddress("glProgramUniform2uiv");
  glProgramUniform3i = (PFNGLPROGRAMUNIFORM3IPROC)glfwGetProcAddress("glProgramUniform3i");
  glProgramUniform3iv = (PFNGLPROGRAMUNIFORM3IVPROC)glfwGetProcAddress("glProgramUniform3iv");
  glProgramUniform3f = (PFNGLPROGRAMUNIFORM3FPROC)glfwGetProcAddress("glProgramUniform3f");
  glProgramUniform3fv = (PFNGLPROGRAMUNIFORM3FVPROC)glfwGetProcAddress("glProgramUniform3fv");
  glProgramUniform3d = (PFNGLPROGRAMUNIFORM3DPROC)glfwGetProcAddress("glProgramUniform3d");
  glProgramUniform3dv = (PFNGLPROGRAMUNIFORM3DVPROC)glfwGetProcAddress("glProgramUniform3dv");
  glProgramUniform3ui = (PFNGLPROGRAMUNIFORM3UIPROC)glfwGetProcAddress("glProgramUniform3ui");
  glProgramUniform3uiv = (PFNGLPROGRAMUNIFORM3UIVPROC)glfwGetProcAddress("glProgramUniform3uiv");
  glProgramUniform4i = (PFNGLPROGRAMUNIFORM4IPROC)glfwGetProcAddress("glProgramUniform4i");
  glProgramUniform4iv = (PFNGLPROGRAMUNIFORM4IVPROC)glfwGetProcAddress("glProgramUniform4iv");
  glProgramUniform4f = (PFNGLPROGRAMUNIFORM4FPROC)glfwGetProcAddress("glProgramUniform4f");
  glProgramUniform4fv = (PFNGLPROGRAMUNIFORM4FVPROC)glfwGetProcAddress("glProgramUniform4fv");
  glProgramUniform4d = (PFNGLPROGRAMUNIFORM4DPROC)glfwGetProcAddress("glProgramUniform4d");
  glProgramUniform4dv = (PFNGLPROGRAMUNIFORM4DVPROC)glfwGetProcAddress("glProgramUniform4dv");
  glProgramUniform4ui = (PFNGLPROGRAMUNIFORM4UIPROC)glfwGetProcAddress("glProgramUniform4ui");
  glProgramUniform4uiv = (PFNGLPROGRAMUNIFORM4UIVPROC)glfwGetProcAddress("glProgramUniform4uiv");
  glProgramUniformMatrix2fv = (PFNGLPROGRAMUNIFORMMATRIX2FVPROC)glfwGetProcAddress("glProgramUniformMatrix2fv");
  glProgramUniformMatrix3fv = (PFNGLPROGRAMUNIFORMMATRIX3FVPROC)glfwGetProcAddress("glProgramUniformMatrix3fv");
  glProgramUniformMatrix4fv = (PFNGLPROGRAMUNIFORMMATRIX4FVPROC)glfwGetProcAddress("glProgramUniformMatrix4fv");
  glProgramUniformMatrix2dv = (PFNGLPROGRAMUNIFORMMATRIX2DVPROC)glfwGetProcAddress("glProgramUniformMatrix2dv");
  glProgramUniformMatrix3dv = (PFNGLPROGRAMUNIFORMMATRIX3DVPROC)glfwGetProcAddress("glProgramUniformMatrix3dv");
  glProgramUniformMatrix4dv = (PFNGLPROGRAMUNIFORMMATRIX4DVPROC)glfwGetProcAddress("glProgramUniformMatrix4dv");
  glProgramUniformMatrix2x3fv = (PFNGLPROGRAMUNIFORMMATRIX2X3FVPROC)glfwGetProcAddress("glProgramUniformMatrix2x3fv");
  glProgramUniformMatrix3x2fv = (PFNGLPROGRAMUNIFORMMATRIX3X2FVPROC)glfwGetProcAddress("glProgramUniformMatrix3x2fv");
  glProgramUniformMatrix2x4fv = (PFNGLPROGRAMUNIFORMMATRIX2X4FVPROC)glfwGetProcAddress("glProgramUniformMatrix2x4fv");
  glProgramUniformMatrix4x2fv = (PFNGLPROGRAMUNIFORMMATRIX4X2FVPROC)glfwGetProcAddress("glProgramUniformMatrix4x2fv");
  glProgramUniformMatrix3x4fv = (PFNGLPROGRAMUNIFORMMATRIX3X4FVPROC)glfwGetProcAddress("glProgramUniformMatrix3x4fv");
  glProgramUniformMatrix4x3fv = (PFNGLPROGRAMUNIFORMMATRIX4X3FVPROC)glfwGetProcAddress("glProgramUniformMatrix4x3fv");
  glProgramUniformMatrix2x3dv = (PFNGLPROGRAMUNIFORMMATRIX2X3DVPROC)glfwGetProcAddress("glProgramUniformMatrix2x3dv");
  glProgramUniformMatrix3x2dv = (PFNGLPROGRAMUNIFORMMATRIX3X2DVPROC)glfwGetProcAddress("glProgramUniformMatrix3x2dv");
  glProgramUniformMatrix2x4dv = (PFNGLPROGRAMUNIFORMMATRIX2X4DVPROC)glfwGetProcAddress("glProgramUniformMatrix2x4dv");
  glProgramUniformMatrix4x2dv = (PFNGLPROGRAMUNIFORMMATRIX4X2DVPROC)glfwGetProcAddress("glProgramUniformMatrix4x2dv");
  glProgramUniformMatrix3x4dv = (PFNGLPROGRAMUNIFORMMATRIX3X4DVPROC)glfwGetProcAddress("glProgramUniformMatrix3x4dv");
  glProgramUniformMatrix4x3dv = (PFNGLPROGRAMUNIFORMMATRIX4X3DVPROC)glfwGetProcAddress("glProgramUniformMatrix4x3dv");
  glValidateProgramPipeline = (PFNGLVALIDATEPROGRAMPIPELINEPROC)glfwGetProcAddress("glValidateProgramPipeline");
  glGetProgramPipelineInfoLog = (PFNGLGETPROGRAMPIPELINEINFOLOGPROC)glfwGetProcAddress("glGetProgramPipelineInfoLog");
  glVertexAttribL1d = (PFNGLVERTEXATTRIBL1DPROC)glfwGetProcAddress("glVertexAttribL1d");
  glVertexAttribL2d = (PFNGLVERTEXATTRIBL2DPROC)glfwGetProcAddress("glVertexAttribL2d");
  glVertexAttribL3d = (PFNGLVERTEXATTRIBL3DPROC)glfwGetProcAddress("glVertexAttribL3d");
  glVertexAttribL4d = (PFNGLVERTEXATTRIBL4DPROC)glfwGetProcAddress("glVertexAttribL4d");
  glVertexAttribL1dv = (PFNGLVERTEXATTRIBL1DVPROC)glfwGetProcAddress("glVertexAttribL1dv");
  glVertexAttribL2dv = (PFNGLVERTEXATTRIBL2DVPROC)glfwGetProcAddress("glVertexAttribL2dv");
  glVertexAttribL3dv = (PFNGLVERTEXATTRIBL3DVPROC)glfwGetProcAddress("glVertexAttribL3dv");
  glVertexAttribL4dv = (PFNGLVERTEXATTRIBL4DVPROC)glfwGetProcAddress("glVertexAttribL4dv");
  glVertexAttribLPointer = (PFNGLVERTEXATTRIBLPOINTERPROC)glfwGetProcAddress("glVertexAttribLPointer");
  glGetVertexAttribLdv = (PFNGLGETVERTEXATTRIBLDVPROC)glfwGetProcAddress("glGetVertexAttribLdv");
  glViewportArrayv = (PFNGLVIEWPORTARRAYVPROC)glfwGetProcAddress("glViewportArrayv");
  glViewportIndexedf = (PFNGLVIEWPORTINDEXEDFPROC)glfwGetProcAddress("glViewportIndexedf");
  glViewportIndexedfv = (PFNGLVIEWPORTINDEXEDFVPROC)glfwGetProcAddress("glViewportIndexedfv");
  glScissorArrayv = (PFNGLSCISSORARRAYVPROC)glfwGetProcAddress("glScissorArrayv");
  glScissorIndexed = (PFNGLSCISSORINDEXEDPROC)glfwGetProcAddress("glScissorIndexed");
  glScissorIndexedv = (PFNGLSCISSORINDEXEDVPROC)glfwGetProcAddress("glScissorIndexedv");
  glDepthRangeArrayv = (PFNGLDEPTHRANGEARRAYVPROC)glfwGetProcAddress("glDepthRangeArrayv");
  glDepthRangeIndexed = (PFNGLDEPTHRANGEINDEXEDPROC)glfwGetProcAddress("glDepthRangeIndexed");
  glGetFloati_v = (PFNGLGETFLOATI_VPROC)glfwGetProcAddress("glGetFloati_v");
  glGetDoublei_v = (PFNGLGETDOUBLEI_VPROC)glfwGetProcAddress("glGetDoublei_v");
  glDrawArraysInstancedBaseInstance = (PFNGLDRAWARRAYSINSTANCEDBASEINSTANCEPROC)glfwGetProcAddress("glDrawArraysInstancedBaseInstance");
  glDrawElementsInstancedBaseInstance = (PFNGLDRAWELEMENTSINSTANCEDBASEINSTANCEPROC)glfwGetProcAddress("glDrawElementsInstancedBaseInstance");
  glDrawElementsInstancedBaseVertexBaseInstance = (PFNGLDRAWELEMENTSINSTANCEDBASEVERTEXBASEINSTANCEPROC)glfwGetProcAddress("glDrawElementsInstancedBaseVertexBaseInstance");
  glDrawTransformFeedbackInstanced = (PFNGLDRAWTRANSFORMFEEDBACKINSTANCEDPROC)glfwGetProcAddress("glDrawTransformFeedbackInstanced");
  glDrawTransformFeedbackStreamInstanced = (PFNGLDRAWTRANSFORMFEEDBACKSTREAMINSTANCEDPROC)glfwGetProcAddress("glDrawTransformFeedbackStreamInstanced");
  glGetInternalformativ = (PFNGLGETINTERNALFORMATIVPROC)glfwGetProcAddress("glGetInternalformativ");
  glGetActiveAtomicCounterBufferiv = (PFNGLGETACTIVEATOMICCOUNTERBUFFERIVPROC)glfwGetProcAddress("glGetActiveAtomicCounterBufferiv");
  glBindImageTexture = (PFNGLBINDIMAGETEXTUREPROC)glfwGetProcAddress("glBindImageTexture");
  glMemoryBarrier = (PFNGLMEMORYBARRIERPROC)glfwGetProcAddress("glMemoryBarrier");
  glTexStorage1D = (PFNGLTEXSTORAGE1DPROC)glfwGetProcAddress("glTexStorage1D");
  glTexStorage2D = (PFNGLTEXSTORAGE2DPROC)glfwGetProcAddress("glTexStorage2D");
  glTexStorage3D = (PFNGLTEXSTORAGE3DPROC)glfwGetProcAddress("glTexStorage3D");
  glDebugMessageControl = (PFNGLDEBUGMESSAGECONTROLPROC)glfwGetProcAddress("glDebugMessageControl");
  glDebugMessageInsert = (PFNGLDEBUGMESSAGEINSERTPROC)glfwGetProcAddress("glDebugMessageInsert");
  glDebugMessageCallback = (PFNGLDEBUGMESSAGECALLBACKPROC)glfwGetProcAddress("glDebugMessageCallback");
  glGetDebugMessageLog = (PFNGLGETDEBUGMESSAGELOGPROC)glfwGetProcAddress("glGetDebugMessageLog");
  glPushDebugGroup = (PFNGLPUSHDEBUGGROUPPROC)glfwGetProcAddress("glPushDebugGroup");
  glPopDebugGroup = (PFNGLPOPDEBUGGROUPPROC)glfwGetProcAddress("glPopDebugGroup");
  glObjectLabel = (PFNGLOBJECTLABELPROC)glfwGetProcAddress("glObjectLabel");
  glGetObjectLabel = (PFNGLGETOBJECTLABELPROC)glfwGetProcAddress("glGetObjectLabel");
  glObjectPtrLabel = (PFNGLOBJECTPTRLABELPROC)glfwGetProcAddress("glObjectPtrLabel");
  glGetObjectPtrLabel = (PFNGLGETOBJECTPTRLABELPROC)glfwGetProcAddress("glGetObjectPtrLabel");
  glClearBufferData = (PFNGLCLEARBUFFERDATAPROC)glfwGetProcAddress("glClearBufferData");
  glClearBufferSubData = (PFNGLCLEARBUFFERSUBDATAPROC)glfwGetProcAddress("glClearBufferSubData");
  glDispatchCompute = (PFNGLDISPATCHCOMPUTEPROC)glfwGetProcAddress("glDispatchCompute");
  glDispatchComputeIndirect = (PFNGLDISPATCHCOMPUTEINDIRECTPROC)glfwGetProcAddress("glDispatchComputeIndirect");
  glCopyImageSubData = (PFNGLCOPYIMAGESUBDATAPROC)glfwGetProcAddress("glCopyImageSubData");
  glTextureView = (PFNGLTEXTUREVIEWPROC)glfwGetProcAddress("glTextureView");
  glBindVertexBuffer = (PFNGLBINDVERTEXBUFFERPROC)glfwGetProcAddress("glBindVertexBuffer");
  glVertexAttribFormat = (PFNGLVERTEXATTRIBFORMATPROC)glfwGetProcAddress("glVertexAttribFormat");
  glVertexAttribIFormat = (PFNGLVERTEXATTRIBIFORMATPROC)glfwGetProcAddress("glVertexAttribIFormat");
  glVertexAttribLFormat = (PFNGLVERTEXATTRIBLFORMATPROC)glfwGetProcAddress("glVertexAttribLFormat");
  glVertexAttribBinding = (PFNGLVERTEXATTRIBBINDINGPROC)glfwGetProcAddress("glVertexAttribBinding");
  glVertexBindingDivisor = (PFNGLVERTEXBINDINGDIVISORPROC)glfwGetProcAddress("glVertexBindingDivisor");
  glFramebufferParameteri = (PFNGLFRAMEBUFFERPARAMETERIPROC)glfwGetProcAddress("glFramebufferParameteri");
  glGetFramebufferParameteriv = (PFNGLGETFRAMEBUFFERPARAMETERIVPROC)glfwGetProcAddress("glGetFramebufferParameteriv");
  glGetInternalformati64v = (PFNGLGETINTERNALFORMATI64VPROC)glfwGetProcAddress("glGetInternalformati64v");
  glInvalidateTexSubImage = (PFNGLINVALIDATETEXSUBIMAGEPROC)glfwGetProcAddress("glInvalidateTexSubImage");
  glInvalidateTexImage = (PFNGLINVALIDATETEXIMAGEPROC)glfwGetProcAddress("glInvalidateTexImage");
  glInvalidateBufferSubData = (PFNGLINVALIDATEBUFFERSUBDATAPROC)glfwGetProcAddress("glInvalidateBufferSubData");
  glInvalidateBufferData = (PFNGLINVALIDATEBUFFERDATAPROC)glfwGetProcAddress("glInvalidateBufferData");
  glInvalidateFramebuffer = (PFNGLINVALIDATEFRAMEBUFFERPROC)glfwGetProcAddress("glInvalidateFramebuffer");
  glInvalidateSubFramebuffer = (PFNGLINVALIDATESUBFRAMEBUFFERPROC)glfwGetProcAddress("glInvalidateSubFramebuffer");
  glMultiDrawArraysIndirect = (PFNGLMULTIDRAWARRAYSINDIRECTPROC)glfwGetProcAddress("glMultiDrawArraysIndirect");
  glMultiDrawElementsIndirect = (PFNGLMULTIDRAWELEMENTSINDIRECTPROC)glfwGetProcAddress("glMultiDrawElementsIndirect");
  glGetProgramInterfaceiv = (PFNGLGETPROGRAMINTERFACEIVPROC)glfwGetProcAddress("glGetProgramInterfaceiv");
  glGetProgramResourceIndex = (PFNGLGETPROGRAMRESOURCEINDEXPROC)glfwGetProcAddress("glGetProgramResourceIndex");
  glGetProgramResourceName = (PFNGLGETPROGRAMRESOURCENAMEPROC)glfwGetProcAddress("glGetProgramResourceName");
  glGetProgramResourceiv = (PFNGLGETPROGRAMRESOURCEIVPROC)glfwGetProcAddress("glGetProgramResourceiv");
  glGetProgramResourceLocation = (PFNGLGETPROGRAMRESOURCELOCATIONPROC)glfwGetProcAddress("glGetProgramResourceLocation");
  glGetProgramResourceLocationIndex = (PFNGLGETPROGRAMRESOURCELOCATIONINDEXPROC)glfwGetProcAddress("glGetProgramResourceLocationIndex");
  glShaderStorageBlockBinding = (PFNGLSHADERSTORAGEBLOCKBINDINGPROC)glfwGetProcAddress("glShaderStorageBlockBinding");
  glTexBufferRange = (PFNGLTEXBUFFERRANGEPROC)glfwGetProcAddress("glTexBufferRange");
  glTexStorage2DMultisample = (PFNGLTEXSTORAGE2DMULTISAMPLEPROC)glfwGetProcAddress("glTexStorage2DMultisample");
  glTexStorage3DMultisample = (PFNGLTEXSTORAGE3DMULTISAMPLEPROC)glfwGetProcAddress("glTexStorage3DMultisample");
}
#endif

/*
** ゲームグラフィックス特論の都合にもとづく初期化
*/
bool gg::ggInit(int width, int height, int redbits, int greenbits, int bluebits, int alphabits, int depthbits, int stencilbits, int mode)
{
  // glfw の初期化
  if (glfwInit() == GL_FALSE)
  {
#if defined(_WIN32)
    MessageBox(NULL, L"エラー: GLFW の初期化に失敗しました", L"GG特論", MB_OK);
#else
    std::cerr << "Error: Failed to initialize GLFW." << std::endl;
#endif
    return false;
  }

  // OpenGL Version 3.2 Core Profile を選択する
  glfwOpenWindowHint(GLFW_OPENGL_VERSION_MAJOR, 3);
  glfwOpenWindowHint(GLFW_OPENGL_VERSION_MINOR, 2);
  glfwOpenWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);

  // GLFW のウィンドウを開く
  if (glfwOpenWindow(width, height, redbits, greenbits, bluebits, alphabits, depthbits, stencilbits, mode) == GL_FALSE)
  {
    // ウィンドウが開けない
#if defined(_WIN32)
    MessageBox(NULL, L"エラー: OpenGL Version 3.2 以降に対応したビデオカードが必要です", L"GG特論", MB_OK);
#else
    std::cerr << "Error: This program requires OpenGL 3.2 or lator." << std::endl;
#endif
    return false;
  }

#if defined(_WIN32)
  // VisualStudio に用意されていない OpenGL のライブラリ関数を有効にする
  initGLExtFunc();
#endif

  // 垂直同期を待つ
  glfwSwapInterval(1);

  return true;
}

/*
** OpenGL のエラーチェック
*/
void gg::ggError(const char *msg)
{
  GLenum error = glGetError();

  if (error != GL_NO_ERROR)
  {
    if (msg) std::cerr << msg << ": ";

    switch (error)
    {
    case GL_INVALID_ENUM:
      std::cerr << "An unacceptable value is specified for an enumerated argument" << std::endl;
      break;
    case GL_INVALID_VALUE:
      std::cerr << "A numeric argument is out of range" << std::endl;
      break;
    case GL_INVALID_OPERATION:
      std::cerr << "The specified operation is not allowed in the current state" << std::endl;
      break;
    case GL_OUT_OF_MEMORY:
      std::cerr << "There is not enough memory left to execute the command" << std::endl;
      break;
    case GL_INVALID_FRAMEBUFFER_OPERATION:
      std::cerr << "The specified operation is not allowed current frame buffer" << std::endl;
      break;
    default:
      std::cerr << "An OpenGL error has occured: " << std::hex << std::showbase << error << std::endl;
      break;
    }
  }
}

/*
** FBO のエラーチェック
*/
void gg::ggFBOError(const char *msg)
{
  GLenum status = glCheckFramebufferStatus(GL_FRAMEBUFFER);

  if (status != GL_FRAMEBUFFER_COMPLETE)
  {
    if (msg) std::cerr << msg << ": ";

    switch (status)
    {
    case GL_FRAMEBUFFER_UNSUPPORTED:
      std::cerr << "Unsupported framebuffer internal" << std::endl;
      break;
    case GL_FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:
      std::cerr << "Framebuffer incomplete, missing attachment" << std::endl;
      break;
    case GL_FRAMEBUFFER_INCOMPLETE_ATTACHMENT:
      std::cerr << "Framebuffer incomplete, duplicate attachment" << std::endl;
      break;
    case GL_FRAMEBUFFER_INCOMPLETE_DRAW_BUFFER:
      std::cerr << "Framebuffer incomplete, missing draw buffer" << std::endl;
      break;
    case GL_FRAMEBUFFER_INCOMPLETE_READ_BUFFER:
      std::cerr << "Framebuffer incomplete, missing read buffer" << std::endl;
      break;
    default:
      std::cerr << "Programming error; will fail on all hardware: " << std::hex << std::showbase << status << std::endl;
      break;
    }
  }
}

/*
** 配列の内容を TGA ファイルに保存
*/
bool gg::ggSaveTga(GLsizei sx, GLsizei sy, unsigned int depth, const GLubyte *buffer, const char *name)
{
  // ファイルを開く
  std::ofstream file(name, std::ios::binary);
  if (file.fail())
  {
    // 開けなかった
    std::cerr << "Waring: Can't open file: " << name << std::endl;
    return false;
  }

  // ヘッダの書き込み
  const unsigned char header[18] =
  {
    0,          // ID length
    0,          // Color map type (none)
    static_cast<unsigned char>((depth == 3) ? 2 : 3), // Image Type (2:RGB, 3:Grayscale)
    0, 0,       // Offset into the color map table
    0, 0,       // Number of color map entries
    0,          // Number of a color map entry bits per pixel
    0, 0,       // Horizontal image position
    0, 0,       // Vertical image position
    static_cast<unsigned char>(sx & 0xff),
    static_cast<unsigned char>(sx >> 8),
    static_cast<unsigned char>(sy & 0xff),
    static_cast<unsigned char>(sy >> 8),
    static_cast<unsigned char>(8 * depth),  // Pixel depth (bits per pixel)
    0           // Image descriptor
  };
  file.write(reinterpret_cast<const char *>(header), sizeof header);
  if (file.bad())
  {
    // ヘッダの書き込みに失敗した
    std::cerr << "Waring: Can't write file header: " << name << std::endl;
    file.close();
    return 0;
  }

  // データの書き込み
  file.write(reinterpret_cast<const char *>(buffer), sx * sy * depth);

  // フッタの書き込み
  static const char footer[] = "\0\0\0\0\0\0\0\0TRUEVISION-XFILE.";
  file.write(footer, sizeof footer);

  // 書き込みチェック
  if (file.bad())
  {
    // 書き込みに失敗した
    std::cerr << "Waring: Can't write image data: " << name << std::endl;
  }

  // ファイルを閉じる
  file.close();

  return true;
}

/*
** カラーバッファの内容を TGA ファイルに保存
*/
bool gg::ggSaveColor(const char *name)
{
  // 現在のビューポートのサイズを得る
  GLint viewport[4];
  glGetIntegerv(GL_VIEWPORT, viewport);
  
  // ビューポートのサイズ分のメモリを確保する
  size_t size = viewport[2] * viewport[3] * 3;
  GLubyte *buffer = 0;
  try
  {
    buffer = new GLubyte[size];
  }
  catch (std::bad_alloc e)
  {
    // メモリ確保に失敗した
    std::cerr << "Waring: Can't allocate memory to write file: " << name << std::endl;
    return false;
  }

  // 画面表示の完了を待つ
  glFinish();

  // カラーバッファの読み込み
  glReadPixels(viewport[0], viewport[1], viewport[2], viewport[3],
    GL_BGR, GL_UNSIGNED_BYTE, buffer);

  // 読み込んだデータをファイルに書き込む
  bool ret = ggSaveTga(viewport[2], viewport[3], 3, buffer, name);

  // メモリの解放
  delete[] buffer;
  
  return ret;
}

/*
** デプスバッファの内容を TGA ファイルに保存
*/
bool gg::ggSaveDepth(const char *name)
{
  // 現在のビューポートのサイズを得る
  GLint viewport[4];
  glGetIntegerv(GL_VIEWPORT, viewport);
  
  // ビューポートのサイズ分のメモリを確保する
  size_t size = viewport[2] * viewport[3];
  GLubyte *buffer = 0;
  try
  {
    buffer = new GLubyte[size];
  }
  catch (std::bad_alloc e)
  {
    // メモリ確保に失敗した
    std::cerr << "Waring: Can't allocate memory to write file: " << name << std::endl;
    return false;
  }

  // 画面表示の完了を待つ
  glFinish();

  // デプスバッファの読み込み
  glReadPixels(viewport[0], viewport[1], viewport[2], viewport[3],
    GL_DEPTH_COMPONENT, GL_UNSIGNED_BYTE, buffer);
    
  // 読み込んだデータをファイルに書き込む
  bool ret = ggSaveTga(viewport[2], viewport[3], 1, buffer, name);

  // メモリの解放
  delete[] buffer;
  
  return ret;
}

/*
** TGA ファイル (8/16/24/32bit) の読み込み
*/
GLubyte *gg::ggLoadTga(const char *name, GLsizei &width, GLsizei &height, GLenum &format)
{
  // ファイルを開く
  std::ifstream file(name, std::ios::binary);
  if (file.fail())
  {
    // 開けなかった
    std::cerr << "Waring: Can't open file: " << name << std::endl;
    return 0;
  }

  // ヘッダの読み込み
  unsigned char header[18];
  file.read(reinterpret_cast<char *>(header), sizeof header);
  if (file.bad())
  {
    // ヘッダの読み込みに失敗した
    std::cerr << "Waring: Can't read file header: " << name << std::endl;
    file.close();
    return 0;
  }

  // 幅と高さ
  width = header[13] << 8 | header[12];
  height = header[15] << 8 | header[14];

  // 深度
  size_t depth = header[16] / 8;
  switch (depth)
  {
    case 1:
      format = GL_RED;
      break;
    case 2:
      format = GL_RG;
      break;
    case 3:
      format = GL_BGR;
      break;
    case 4:
      format = GL_BGRA;
      break;
    default:
      std::cerr << "Waring: Unusable format: " << depth << std::endl;
      file.close();
      return 0;
  }

  // データサイズ
  size_t size = width * height * depth;

  // メモリの確保
  GLubyte *buffer = 0;
  try
  {
    buffer = new GLubyte[size];
  }
  catch (std::bad_alloc e)
  {
    // メモリが足らなかった
    std::cerr << "Waring: Too large file: " << name << std::endl;
    file.close();
    return 0;
  }

  // データの読み込み
  if (header[2] & 8)
  {
    // RLE
    size_t p = 0;
    char c;
    while (file.get(c))
    {
      if (c & 0x80)
      {
        // run-length packet
        size_t count = (c & 0x7f) + 1;
        if (p + count * depth > size) break;
        char tmp[4];
        file.read(tmp, depth);
        for (size_t i = 0; i < count; ++i)
        {
          memcpy(reinterpret_cast<char *>(buffer + p), tmp, depth);
          p += depth;
        }
      }
      else
      {
        // raw packet
        size_t count = (c + 1) * depth;
        if (p + count > size) break;
        file.read(reinterpret_cast<char *>(buffer + p), count);
        p += count;
      }
    }
  }
  else
  {
    // 非圧縮
    file.read(reinterpret_cast<char *>(buffer), size);
  }

  // 読み込みチェック
  if (file.bad())
  {
    // 読み込みに失敗した
    std::cerr << "Waring: Can't read image data: " << name << std::endl;
  }

  // ファイルを閉じる
  file.close();

  return buffer;
}

/*
** テクスチャマッピング用のデータの読み込み
*/
void gg::ggLoadTexture(GLsizei width, GLsizei height, GLenum internal, GLenum format, const GLvoid *image)
{
  // アルファチャンネルがついていれば 4 バイト境界に設定
  glPixelStorei(GL_UNPACK_ALIGNMENT, (format == GL_BGRA || format == GL_RGBA) ? 4 : 1);

  // テクスチャを割り当てる
  glTexImage2D(GL_TEXTURE_2D, 0, internal, width, height, 0, format, GL_UNSIGNED_BYTE, image);

  // バイリニア（ミップマップなし），エッジでクランプ
  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
}

/*
** テクスチャマッピング用の TGA 画像ファイルの読み込み
*/
bool gg::ggLoadImage(const char *name, GLenum internal)
{
  // 画像サイズ
  GLsizei width, height;

  // 画像フォーマット
  GLenum format;

  // 画像の読み込み先
  GLubyte *image = ggLoadTga(name, width, height, format);

  // テクスチャメモリへの読み込み
  ggLoadTexture(width, height, internal, format, image);

  // 読み込みに使ったメモリを開放する
  delete[] image;

  return true;
}

/*
** 高さマップ用の TGA 画像ファイルの読み込んで法線マップを作成する
*/
bool gg::ggLoadHeight(const char *name, float nz)
{
  // 画像サイズ
  GLsizei width, height;

  // 画像フォーマット
  GLenum format;

  // 画像の読み込み先
  GLubyte *hmap = ggLoadTga(name, width, height, format);

  // 画像が読み込めなかったら戻る
  if (hmap == 0) return false;

  // 作成する法線マップ
  GLfloat (*nmap)[4] = 0;

  // メモリサイズ
  GLsizei maxsize = width * height;

  // メモリを確保する
  try
  {
    nmap = new GLfloat[maxsize][4];
  }
  catch (std::bad_alloc e)
  {
    delete[] hmap;
    return false;
  }

  // 法線マップの作成
  for (GLsizei i = 0; i < maxsize; ++i)
  {
    int x = i % width, y = i - x;

    // 隣接する画素との値の差を法線の成分に用いる
    float nx = static_cast<float>(hmap[y + (x + 1) % width] - hmap[i]);
    float ny = static_cast<float>(hmap[(y + width) % maxsize + x] - hmap[i]);

    // 法線の長さを求めておく
    float nl = sqrt(nx * nx + ny * ny + nz * nz);

    // 法線を求める
    nmap[i][0] = nx * 0.5f / nl + 0.5f;
    nmap[i][1] = ny * 0.5f / nl + 0.5f;
    nmap[i][2] = nz * 0.5f / nl + 0.5f;
    nmap[i][3] = hmap[i] * 0.0039215686f; // == 1/255
  }

  // 高さマップの読み込みに使ったメモリを開放する
  delete[] hmap;

  // nmap が GLfloat なので 4 バイト境界に設定
  glPixelStorei(GL_UNPACK_ALIGNMENT, 4);

  // テクスチャを割り当てる
  glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, width, height, 0, GL_RGBA, GL_FLOAT, nmap);

  // バイリニア（ミップマップなし），エッジでクランプ
  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_MIRRORED_REPEAT);
  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_MIRRORED_REPEAT);

  // 法線マップの作成に使ったメモリを解放する
  delete[] nmap;

  return true;
}

/*
** 三角形分割された OBJ ファイルを読み込む
*/
bool gg::ggLoadObj(const char *name, GLuint &nv, GLfloat (*&vert)[3], GLfloat (*&norm)[3], GLuint &nf, GLuint (*&face)[3], bool normalize)
{
  // OBJ ファイルの読み込み
  std::ifstream file(name, std::ios::binary);
  if (file.fail())
  {
    std::cerr << "Error: Can't open OBJ file: " << name << std::endl;
    return false;
  }

  // 一行読み込み用のバッファ
  std::string line;

  // データの数と座標値の最小値・最大値
  float xmin, xmax, ymin, ymax, zmin, zmax;
  xmax = ymax = zmax = -(xmin = ymin = zmin = FLT_MAX);
  nv = nf = 0;

  // データを読み込む
  while (std::getline(file, line))
  {
    std::istringstream str(line);
    std::string op;
    str >> op;

    if (op == "v")
    {
      // 頂点位置
      float x, y, z;

      // 頂点位置はスペースで区切られている
      str >> x >> y >> z;

      // 位置の最大値と最小値を求める (AABB)
      if (x < xmin) xmin = x;
      if (x > xmax) xmax = x;

      if (y < ymin) ymin = y;
      if (y > ymax) ymax = y;

      if (z < zmin) zmin = z;
      if (z > zmax) zmax = z;

      // 頂点数のカウント
      ++nv;
    }
    else if (op == "f")
    {
      // 面数のカウント
      ++nf;
    }
  }

  // メモリの確保
  GLfloat (*fnorm)[3] = 0;
  vert = norm = 0;
  face = 0;
  try
  {
    vert = new GLfloat[nv][3];
    norm = new GLfloat[nv][3];
    face = new GLuint[nf][3];
    fnorm = new GLfloat[nf][3];
  }
  catch (std::bad_alloc e)
  {
    delete[] vert;
    delete[] norm;
    delete[] face;
    vert = norm = 0;
    face = 0;
    file.close();
    return false;
  }

  // 位置と大きさの正規化のための係数
  GLfloat scale, cx, cy, cz;
  if (normalize)
  {
    float sx = xmax - xmin;
    float sy = ymax - ymin;
    float sz = zmax - zmin;
    scale = sx;
    if (sy > scale) scale = sy;
    if (sz > scale) scale = sz;
    scale = (scale != 0.0f) ? 2.0f / scale : 1.0f;
    cx = (xmax + xmin) * 0.5f;
    cy = (ymax + ymin) * 0.5f;
    cz = (zmax + zmin) * 0.5f;
  }
  else
  {
    scale = 1.0f;
    cx = cy = cz = 0.0f;
  }

  // ファイルの巻き戻し
  file.clear();
  file.seekg(0L, std::ios::beg);

  // データの読み込み
  nv = nf = 0;
  while (std::getline(file, line))
  {
    std::istringstream str(line);
    std::string op;
    str >> op;

    if (op == "v")
    {
      // 頂点位置
      float x, y, z;

      // 頂点位置はスペースで区切られている
      str >> x >> y >> z;

      // 位置と大きさの正規化
      vert[nv][0] = (x - cx) * scale;
      vert[nv][1] = (y - cy) * scale;
      vert[nv][2] = (z - cz) * scale;

      // 頂点数のカウント
      ++nv;
    }
    else if (op == "f")
    {
      // 頂点座標番号
      std::string l, m, n;

      // 頂点座標番号/テクスチャ座標番号/法線番号の組を取り出す
      str >> l >> m >> n;

      // 頂点座標番号だけ整数化する
      face[nf][0] = atoi(l.c_str()) - 1;
      face[nf][1] = atoi(m.c_str()) - 1;
      face[nf][2] = atoi(n.c_str()) - 1;

      // 面数のカウント
      ++nf;
    }
  }

  // ファイルの読み込みチェック
  if (file.bad())
  {
    // うまく読み込めなかった
    std::cerr << "Warning: Can't read OBJ file: " << name << std::endl;
  }
  file.close();

  // 面法線の算出
  for (GLuint f = 0; f < nf; ++f)
  {
    GLuint v0 = face[f][0], v1 = face[f][1], v2 = face[f][2];

    // v1 - v0, v2 - v0 を求める
    GLfloat dx1 = vert[v1][0] - vert[v0][0];
    GLfloat dy1 = vert[v1][1] - vert[v0][1];
    GLfloat dz1 = vert[v1][2] - vert[v0][2];
    GLfloat dx2 = vert[v2][0] - vert[v0][0];
    GLfloat dy2 = vert[v2][1] - vert[v0][1];
    GLfloat dz2 = vert[v2][2] - vert[v0][2];

    // 外積により面法線を求める
    fnorm[f][0] = dy1 * dz2 - dz1 * dy2;
    fnorm[f][1] = dz1 * dx2 - dx1 * dz2;
    fnorm[f][2] = dx1 * dy2 - dy1 * dx2;
  }

  // 頂点法線の値を 0 にしておく
  for (GLuint v = 0; v < nv; ++v)
  {
    norm[v][0] = norm[v][1] = norm[v][2] = 0.0f;
  }

  // 頂点法線の算出
  for (GLuint f = 0; f < nf; ++f)
  {
    // 頂点座標番号
    GLuint v0 = face[f][0], v1 = face[f][1], v2 = face[f][2];

    // 面法線
    GLfloat x = fnorm[f][0];
    GLfloat y = fnorm[f][1];
    GLfloat z = fnorm[f][2];

    // 面法線を頂点法線に積算する
    norm[v0][0] += x;
    norm[v0][1] += y;
    norm[v0][2] += z;

    norm[v1][0] += x;
    norm[v1][1] += y;
    norm[v1][2] += z;

    norm[v2][0] += x;
    norm[v2][1] += y;
    norm[v2][2] += z;
  }

  // 頂点法線の正規化
  for (GLuint v = 0; v < nv; ++v)
  {
    // 頂点法線の長さ
    GLfloat a = sqrt(norm[v][0] * norm[v][0] + norm[v][1] * norm[v][1] + norm[v][2] * norm[v][2]);

    // 頂点法線の正規化
    if (a != 0.0)
    {
      norm[v][0] /= a;
      norm[v][1] /= a;
      norm[v][2] /= a;
    }
  }

  return true;
}

namespace gg
{
  // マテリアル
  struct rgb { float r, g, b; };
  struct mat
  {
    rgb ka;       // ambient
    rgb kd;       // diffuse
    rgb ks;       // specular
    float kshi;   // shininess
  };

  // 読み込み用のテンポラリデータの形式
  struct vec      // ベクトル
  {
    float x, y, z;
  };
  struct vtx      // 頂点属性
  {
    vec pos;      // 頂点位置
    vec norm;     // 頂点法線
  };
  struct fac      // 面データ
  {
    GLuint v[3];  // 頂点番号
    GLuint n[3];  // 法線番号
    vec norm;     // 面法線
  };
  struct grp      // 面グループ
  {
    GLuint b;     // 面グループの開始番号
    GLuint c;     // 面グループの頂点数
    const mat *m; // 面グループのマテリアル
    grp(GLuint begin, GLuint count, const mat &material)
    {
      b = begin;
      c = count;
      m = &material;
    }
  };
}

/*
** 三角形分割された OBJ ファイルと MTL ファイルを読み込む
*/
bool gg::ggLoadObj(const char *name, GLuint &ng, GLuint (*&group)[2],
  GLfloat (*&ka)[4], GLfloat (*&kd)[4], GLfloat (*&ks)[4], GLfloat *&kshi,
  GLuint &nv, GLfloat (*&vert)[3], GLfloat (*&norm)[3], bool normalize)
{
  // ファイルパスからディレクトリ名を取り出す
  std::string path(name);
  size_t pos = path.find_last_of("/\\");
  std::string dirname = (pos == std::string::npos) ? "" : path.substr(pos + 1);

  // OBJ ファイルの読み込み
  std::ifstream file(path.c_str());
  if (file.fail())
  {
    std::cerr << "Error: Can't open OBJ file: " << path << std::endl;
    return false;
  }

  // マテリアル
  std::map<std::string, mat> mtl;
  static const char defmtl[] = "Default";
  std::string mtlname(defmtl);

  // デフォルトのマテリアル
  mtl[mtlname].ka.r = 0.1f;
  mtl[mtlname].ka.g = 0.1f;
  mtl[mtlname].ka.b = 0.1f;
  mtl[mtlname].kd.r = 0.6f;
  mtl[mtlname].kd.g = 0.6f;
  mtl[mtlname].kd.b = 0.6f;
  mtl[mtlname].ks.r = 0.3f;
  mtl[mtlname].ks.g = 0.3f;
  mtl[mtlname].ks.b = 0.3f;
  mtl[mtlname].kshi = 40.0f;

  // 読み込み用の一時記憶領域
  std::vector<vec> _norm;
  std::vector<vtx> _vert;
  std::vector<fac> _face;
  std::vector<grp> _group;

  // 座標値の最小値・最大値
  GLuint groupbegin = 0;
  float xmin, xmax, ymin, ymax, zmin, zmax;
  xmax = ymax = zmax = -(xmin = ymin = zmin = FLT_MAX);

  // 一行読み込み用のバッファ
  std::string line;

  // データの読み込み
  while (std::getline(file, line))
  {
    // １行取り出して最初のトークンを命令 (op) とみなす
    std::istringstream str(line);
    std::string op;
    str >> op;

    if (op == "v")
    {
      // 頂点位置
      vtx v;

      // 頂点位置はスペースで区切られている
      str >> v.pos.x >> v.pos.y >> v.pos.z;

      // 頂点位置の最小値と最大値を求める
      if (v.pos.x < xmin) xmin = v.pos.x;
      if (v.pos.x > xmax) xmax = v.pos.x;

      if (v.pos.y < ymin) ymin = v.pos.y;
      if (v.pos.y > ymax) ymax = v.pos.y;

      if (v.pos.z < zmin) zmin = v.pos.z;
      if (v.pos.z > zmax) zmax = v.pos.z;

      // 頂点位置を記録する
      _vert.push_back(v);
    }
    else if (op == "vn")
    {
      // 頂点法線
      vec norm;

      // 頂点法線はスペースで区切られている
      str >> norm.x >> norm.y >> norm.z;

      // 頂点法線を記録する
      _norm.push_back(norm);
    }
    else if (op == "f")
    {
      // 面 (三角形) データ
      fac f;

      //　三頂点のそれぞれについて
      for (int i = 0; i < 3; ++i)
      {
        // １項目取り出す
        std::string tmp;
        str >> tmp;

        // 項目の最初の要素は頂点座標番号 (0 から始まる)
        f.v[i] = atoi(tmp.c_str()) - 1;
        f.n[i] = 0;

        // 残りの項目を取り出す
        size_t pos = tmp.find('/', 0);
        if (pos != std::string::npos)
        {
          // 二つ目の項目は飛ばす
          pos = tmp.find('/', pos + 1);
          if (pos != std::string::npos)
          {
            // 三つ目の項目は法線番号 (0 なら法線の割り当てなし)
            f.n[i] = atoi(tmp.substr(pos + 1).c_str());
          }
        }
      }

      // 面データの記録ｊ
      _face.push_back(f);
    }
    else if (op == "usemtl")
    {
      // 面グループの面数
      GLuint groupcount = static_cast<GLuint>(_face.size()) * 3 - groupbegin;
      if (groupcount > 0)
      {
        // 面グループの頂点データの開始番号と数，およびそのマテリアルを記録する
        grp b(groupbegin, groupcount, mtl[mtlname]);
        _group.push_back(b);

        // 次の面グループの開始番号を求めておく
        groupbegin += groupcount;
      }

      // マテリアル名の取り出し
      str >> mtlname;

      // マテリアルの存在チェック
      if (mtl.find(mtlname) == mtl.end())
      {
        std::cerr << "Warning: Undefined material: " << mtlname << std::endl;
        mtlname = defmtl;
      }
      else
      {
        std::cerr << "usemtl: " << mtlname << std::endl;
      }
    }
    else if (op == "mtllib")
    {
      // MTL ファイルのパス名を作る
      str >> std::ws;
      std::string mtlpath;
      std::getline(str, mtlpath);
      mtlpath = dirname + mtlpath;

      // MTL ファイルの読み込み
      std::ifstream mtlfile(mtlpath.c_str(), std::ios::binary);
      if (mtlfile.fail())
      {
        std::cerr << "Warning: Can't open MTL file: " << mtlpath << std::endl;
      }
      else
      {
        // 一行読み込み用のバッファ
        std::string mtlline;

        // マテリアルデータを読み込む
        while (std::getline(mtlfile, mtlline))
        {
          std::istringstream mtlstr(mtlline);
          std::string mtlop;
          mtlstr >> mtlop;

          if (mtlop == "newmtl")
          {
            // 新規マテリアル名を出力する
            mtlstr >> mtlname;
            std::cerr << "newmtl: " << mtlname << std::endl;
          }
          else if (mtlop == "Ka")
          {
            // 環境光の反射係数を登録する
            mtlstr >> mtl[mtlname].ka.r >> mtl[mtlname].ka.g >> mtl[mtlname].ka.b;
          }
          else if (mtlop == "Kd")
          {
            // 拡散反射係数を登録する
            mtlstr >> mtl[mtlname].kd.r >> mtl[mtlname].kd.g >> mtl[mtlname].kd.b;
          }
          else if (mtlop == "Ks")
          {
            // 鏡面反射係数を登録する
            mtlstr >> mtl[mtlname].ks.r >> mtl[mtlname].ks.g >> mtl[mtlname].ks.b;
          }
          else if (mtlop == "Ns")
          {
            // 輝き係数を登録する
            float kshi;
            mtlstr >> kshi;
            mtl[mtlname].kshi = kshi * 0.1f;
          }
        }

        // MTL ファイルの読み込みチェック
        if (mtlfile.bad())
        {
          // MTL ファイルをうまく読み込めなかった
          std::cerr << "Warning: Can't read MTL file: " << mtlpath << std::endl;
        }
        mtlfile.close();
      }
    }
  }

  // ファイルの読み込みチェック
  if (file.bad())
  {
    // OBJ ファイルをうまく読み込めなかった
    std::cerr << "Warning: Can't read OBJ file: " << path << std::endl;
  }
  else
  {
    // 最後の面グループの面数
    GLuint groupcount = static_cast<GLuint>(_face.size()) * 3 - groupbegin;
    if (groupcount > 0)
    {
      // 最後の面グループの頂点データの開始番号と数，およびそのマテリアルを記録する
      grp b(groupbegin, groupcount, mtl[mtlname]);
      _group.push_back(b);
    }
  }
  file.close();

  // 必要な面数，頂点数，グループ数
  GLuint nf = static_cast<GLuint>(_face.size());
  nv = nf * 3;
  ng = static_cast<GLuint>(_group.size());

  // メモリの確保
  group = 0;
  ka = kd = ks = 0;
  kshi = 0;
  vert = norm = 0;
  try
  {
    group = new GLuint[ng][2];
    ka = new GLfloat[ng][4];
    kd = new GLfloat[ng][4];
    ks = new GLfloat[ng][4];
    kshi = new GLfloat[ng];
    vert = new GLfloat[nv][3];
    norm = new GLfloat[nv][3];
  }
  catch (std::bad_alloc e)
  {
    delete[] group;
    delete[] ka;
    delete[] kd;
    delete[] ks;
    delete[] kshi;
    delete[] vert;
    delete[] norm;
    group = 0;
    ka = kd = ks = 0;
    kshi = 0;
    vert = norm = 0;
    return false;
  }

  // 位置と大きさを正規化するための係数
  GLfloat scale, cx, cy, cz;
  if (normalize)
  {
    float sx = xmax - xmin;
    float sy = ymax - ymin;
    float sz = zmax - zmin;
    scale = sx;
    if (sy > scale) scale = sy;
    if (sz > scale) scale = sz;
    scale = (scale != 0.0f) ? 2.0f / scale : 1.0f;
    cx = (xmax + xmin) * 0.5f;
    cy = (ymax + ymin) * 0.5f;
    cz = (zmax + zmin) * 0.5f;
  }
  else
  {
    scale = 1.0f;
    cx = cy = cz = 0.0f;
  }

  // 面法線の算出
  for (std::vector<fac>::iterator f = _face.begin(); f != _face.end(); ++f)
  {
    // 頂点座標番号
    GLuint v0 = f->v[0], v1 = f->v[1], v2 = f->v[2];

    // v1 - v0, v2 - v0 を求める
    GLfloat dx1 = _vert[v1].pos.x - _vert[v0].pos.x;
    GLfloat dy1 = _vert[v1].pos.y - _vert[v0].pos.y;
    GLfloat dz1 = _vert[v1].pos.z - _vert[v0].pos.z;
    GLfloat dx2 = _vert[v2].pos.x - _vert[v0].pos.x;
    GLfloat dy2 = _vert[v2].pos.y - _vert[v0].pos.y;
    GLfloat dz2 = _vert[v2].pos.z - _vert[v0].pos.z;

    // 外積により面法線を求める
    f->norm.x = dy1 * dz2 - dz1 * dy2;
    f->norm.y = dz1 * dx2 - dx1 * dz2;
    f->norm.z = dx1 * dy2 - dy1 * dx2;
  }

  // 頂点法線の値を 0 にしておく
  for (std::vector<vtx>::iterator v = _vert.begin(); v != _vert.end(); ++v)
  {
    v->norm.x = v->norm.y = v->norm.z = 0.0f;
  }

  // 頂点法線の算出
  for (std::vector<fac>::iterator f = _face.begin(); f != _face.end(); ++f)
  {
    // 頂点座標番号
    GLuint v0 = f->v[0], v1 = f->v[1], v2 = f->v[2];

    // 面法線
    GLfloat x = f->norm.x;
    GLfloat y = f->norm.y;
    GLfloat z = f->norm.z;

    // 面法線を頂点法線に積算する
    _vert[v0].norm.x += x;
    _vert[v0].norm.y += y;
    _vert[v0].norm.z += z;

    _vert[v1].norm.x += x;
    _vert[v1].norm.y += y;
    _vert[v1].norm.z += z;

    _vert[v2].norm.x += x;
    _vert[v2].norm.y += y;
    _vert[v2].norm.z += z;
  }

  // 頂点法線の正規化
  for (std::vector<vtx>::iterator v = _vert.begin(); v != _vert.end(); ++v)
  {
    // 頂点法線の長さ
    GLfloat a = sqrt(v->norm.x * v->norm.x + v->norm.y * v->norm.y + v->norm.z * v->norm.z);

    // 頂点法線を正規化する
    if (a != 0.0)
    {
      v->norm.x /= a;
      v->norm.y /= a;
      v->norm.z /= a;
    }
  }

  // 面ごとの頂点データの作成
  nv = 0;
  for (std::vector<fac>::iterator f = _face.begin(); f != _face.end(); ++f)
  {
    // 面法線
    GLfloat x = f->norm.x, y = f->norm.y, z = f->norm.z;

    // 面法線の長さ
    GLfloat a = sqrt(x * x + y * y + z * z);

    // 面法線の正規化
    if (a != 0.0)
    {
      x /= a;
      y /= a;
      z /= a;
    }

    // 三頂点のそれぞれについて
    for (int i = 0; i < 3; ++i)
    {
      // 頂点座標番号と頂点法線番号
      GLuint fv = f->v[i], fn = f->n[i];

      // 頂点座標を正規化して登録
      vert[nv][0] = (_vert[fv].pos.x - cx) * scale;
      vert[nv][1] = (_vert[fv].pos.y - cy) * scale;
      vert[nv][2] = (_vert[fv].pos.z - cz) * scale;

      // 法線番号が 0 なら
      if (fn == 0)
      {
        // 頂点法線を保存する
        norm[nv][0] = _vert[fv].norm.x;
        norm[nv][1] = _vert[fv].norm.y;
        norm[nv][2] = _vert[fv].norm.z;
      }
      else
      {
        // 読み込まれた頂点法線を使う
        --fn;
        norm[nv][0] = _norm[fn].x;
        norm[nv][1] = _norm[fn].y;
        norm[nv][2] = _norm[fn].z;
      }

      // 頂点数のカウント
      ++nv;
    }
  }

  // 面グループデータの作成
  ng = 0;
  for (std::vector<grp>::iterator g = _group.begin(); g != _group.end(); ++g)
  {
    // 面グループの最初の頂点位置番号
    group[ng][0] = g->b;

    // 面グループの頂点データの数
    group[ng][1] = g->c;

    // 面グループの環境光に対する反射係数
    ka[ng][0] = g->m->ka.r;
    ka[ng][1] = g->m->ka.g;
    ka[ng][2] = g->m->ka.b;
    ka[ng][3] = 1.0f;

    // 面グループの拡散反射係数
    kd[ng][0] = g->m->kd.r;
    kd[ng][1] = g->m->kd.g;
    kd[ng][2] = g->m->kd.b;
    kd[ng][3] = 1.0f;

    // 面グループの鏡面反射係数
    ks[ng][0] = g->m->ks.r;
    ks[ng][1] = g->m->ks.g;
    ks[ng][2] = g->m->ks.b;
    ks[ng][3] = 1.0f;

    // 面グループの輝き係数
    kshi[ng] = g->m->kshi;

    // 面グループの数
    ++ng;
  }

  return true;
}

/*
** シェーダーのソースプログラムをメモリに読み込む
*/
static bool readShaderSource(GLuint shader, const char *name)
{
  bool ret = true; // 終了ステータス（true ならエラー）

  // ソースファイルを開く
  std::ifstream file(name, std::ios::binary);

  if (file.fail())
  {
    // 開けなかった
    std::cerr << "Error: Can't open source file: " << name << std::endl;
  }
  else
  {
    // ファイルの末尾に移動し現在位置（＝ファイルサイズ）を得る
    file.seekg(0L, std::ios::end);
    GLsizei length = static_cast<GLsizei>(file.tellg());

    // ファイルサイズのメモリを確保
    char *buffer = new GLchar[length];

    // ファイルを先頭から読み込む
    file.seekg(0L, std::ios::beg);
    file.read(buffer, length);

    if (file.bad())
    {
      // うまく読み込めなかった
      std::cerr << "Error: Could not read souce file: " << name << std::endl;
    }
    else {
      // シェーダのソースプログラムのシェーダオブジェクトへの読み込み
      const GLchar *source[] = { buffer };
      glShaderSource(shader, 1, source, &length);
      ret = false;
    }
    file.close();

    // 読み込みに使ったメモリを開放する
    delete[] buffer;
  }

  return ret;
}

/*
** シェーダオブジェクトのコンパイル結果を表示する
*/
static GLboolean printShaderInfoLog(GLuint shader, const char *str)
{
  // コンパイル結果を取得する
  GLint status;
  glGetShaderiv(shader, GL_COMPILE_STATUS, &status);
  if (status == GL_FALSE) std::cerr << "Compile Error in " << str << std::endl;

  // シェーダのコンパイル時のログの長さを取得する
  GLsizei bufSize;
  glGetShaderiv(shader, GL_INFO_LOG_LENGTH , &bufSize);

  if (bufSize > 1)
  {
    // シェーダのコンパイル時のログの内容を取得する
    GLchar *infoLog = new GLchar[bufSize];
    GLsizei length;
    glGetShaderInfoLog(shader, bufSize, &length, infoLog);
    std::cerr << infoLog << std::endl;
    delete[] infoLog;
  }

  return (GLboolean)status;
}

/*
** プログラムオブジェクトのリンク結果を表示する
*/
static GLboolean printProgramInfoLog(GLuint program)
{
  // リンク結果を取得する
  GLint status;
  glGetProgramiv(program, GL_LINK_STATUS, &status);
  if (status == GL_FALSE) std::cerr << "Link Error." << std::endl;

  // シェーダのリンク時のログの長さを取得する
  GLsizei bufSize;
  glGetProgramiv(program, GL_INFO_LOG_LENGTH , &bufSize);

  if (bufSize > 1)
  {
    // シェーダのリンク時のログの内容を取得する
    GLchar *infoLog = new GLchar[bufSize];
    GLsizei length;
    glGetProgramInfoLog(program, bufSize, &length, infoLog);
    std::cerr << infoLog << std::endl;
    delete[] infoLog;
  }

  return (GLboolean)status;
}

/*
** シェーダーソースファイルの読み込み
*/
GLuint gg::ggLoadShader(
  const char *vert,       // バーテックスシェーダのソースファイル名
  const char *frag,       // フラグメントシェーダのソースファイル名
  const char *geom,       // ジオメトリシェーダのソースファイル名
  GLint nvarying,         // Transform Feedback する varying 変数の数
  const char **varyings   // Transform Feedback する varying 変数のリスト
  )
{
  // シェーダプログラムの作成
  GLuint program = glCreateProgram();

  if (program > 0)
  {
    // バーテックスシェーダの作成
    GLuint vertShader = glCreateShader(GL_VERTEX_SHADER);

    // バーテックスシェーダのソースプログラムの読み込み
    if (readShaderSource(vertShader, vert))
    {
      glDeleteShader(vertShader);
      glDeleteProgram(program);
      return 0;
    }

    // バーテックスシェーダのコンパイル
    glCompileShader(vertShader);
    if (printShaderInfoLog(vertShader, vert) == GL_FALSE)
    {
      glDeleteShader(vertShader);
      glDeleteProgram(program);
      return 0;
    }

    // バーテックスシェーダシェーダプログラムへの組み込み
    glAttachShader(program, vertShader);
    glDeleteShader(vertShader);

    if (frag)
    {
      // フラグメントシェーダの作成
      GLuint fragShader = glCreateShader(GL_FRAGMENT_SHADER);

      // フラグメントシェーダのソースプログラムの読み込み
      if (readShaderSource(fragShader, frag))
      {
        glDeleteShader(fragShader);
        glDeleteProgram(program);
        return 0;
      }

      // フラグメントシェーダのコンパイル
      glCompileShader(fragShader);
      if (printShaderInfoLog(fragShader, frag) == GL_FALSE)
      {
        glDeleteShader(fragShader);
        glDeleteProgram(program);
        return 0;
      }

      // フラグメントシェーダシェーダプログラムへの組み込み
      glAttachShader(program, fragShader);
      glDeleteShader(fragShader);
    }

    if (geom)
    {
      // ジオメトリシェーダの作成
      GLuint geomShader = glCreateShader(GL_GEOMETRY_SHADER);

      // ジオメトリシェーダのソースプログラムの読み込み
      if (readShaderSource(geomShader, geom))
      {
        glDeleteShader(geomShader);
        glDeleteProgram(program);
        return 0;
      }

      // ジオメトリシェーダのコンパイル
      glCompileShader(geomShader);
      if (printShaderInfoLog(geomShader, geom) == GL_FALSE)
      {
        glDeleteShader(geomShader);
        glDeleteProgram(program);
        return 0;
      }

      // ジオメトリシェーダのシェーダプログラムへの組み込み
      glAttachShader(program, geomShader);
      glDeleteShader(geomShader);
    }

    // feedback に使う varying 変数を指定する
    if (nvarying > 0) glTransformFeedbackVaryings(program, nvarying, varyings, GL_SEPARATE_ATTRIBS);

    // シェーダプログラムのリンク
    glLinkProgram(program);
    if (printProgramInfoLog(program) == GL_FALSE)
    {
      glDeleteProgram(program);
      return 0;
    }
  }

  return program;
}

/*
** 変換行列：行列とベクトルの積 c ← a × b
*/
void gg::GgMatrix::projection(GLfloat *c, const GLfloat *a, const GLfloat *b) const
{
  for (int i = 0; i < 4; ++i)
  {
    c[i] = a[0 + i] * b[0] + a[4 + i] * b[1] + a[8 + i] * b[2] + a[12 + i] * b[3];
  }
}

/*
** 変換行列：行列と行列の積 c ← a × b
*/
void gg::GgMatrix::multiply(GLfloat *c, const GLfloat *a, const GLfloat *b) const
{
  for (int i = 0; i < 16; ++i)
  {
    int j = i & 3, k = i & ~3;

    c[i] = a[0 + j] * b[k + 0] + a[4 + j] * b[k + 1] + a[8 + j] * b[k + 2] + a[12 + j] * b[k + 3];
  }
}

/*
** 変換行列：単位行列を設定する
*/
gg::GgMatrix &gg::GgMatrix::loadIdentity(void)
{
  array[ 1] = array[ 2] = array[ 3] = array[ 4] =
  array[ 6] = array[ 7] = array[ 8] = array[ 9] =
  array[11] = array[12] = array[13] = array[14] = 0.0f;
  array[ 0] = array[ 5] = array[10] = array[15] = 1.0f;

  return *this;
}

/*
** 変換行列：平行移動変換行列を設定する
*/
gg::GgMatrix &gg::GgMatrix::loadTranslate(GLfloat x, GLfloat y, GLfloat z, GLfloat w)
{
  array[12] = x;
  array[13] = y;
  array[14] = z;
  array[ 0] = array[ 5] = array[10] = array[15] = w;
  array[ 1] = array[ 2] = array[ 3] = array[ 4] =
  array[ 6] = array[ 7] = array[ 8] = array[ 9] =
  array[11] = 0.0f;

  return *this;
}

/*
** 変換行列：拡大縮小変換行列を設定する
*/
gg::GgMatrix &gg::GgMatrix::loadScale(GLfloat x, GLfloat y, GLfloat z, GLfloat w)
{
  array[ 0] = x;
  array[ 5] = y;
  array[10] = z;
  array[15] = w;
  array[ 1] = array[ 2] = array[ 3] = array[ 4] =
  array[ 6] = array[ 7] = array[ 8] = array[ 9] =
  array[11] = array[12] = array[13] = array[14] = 0.0f;

  return *this;
}

/*
** 変換行列：x 軸中心の回転変換行列を設定する
*/
gg::GgMatrix &gg::GgMatrix::loadRotateX(GLfloat a)
{
  GLfloat c = cos(a);
  GLfloat s = sin(a);

  array[ 0] = 1.0f; array[ 1] = 0.0f; array[ 2] = 0.0f; array[ 3] = 0.0f;
  array[ 4] = 0.0f; array[ 5] = c;    array[ 6] = s;    array[ 7] = 0.0f;
  array[ 8] = 0.0f; array[ 9] = -s;   array[10] = c;    array[11] = 0.0f;
  array[12] = 0.0f; array[13] = 0.0f; array[14] = 0.0f; array[15] = 1.0f;

  return *this;
}

/*
** 変換行列：y 軸中心の回転変換行列を設定する
*/
gg::GgMatrix &gg::GgMatrix::loadRotateY(GLfloat a)
{
  GLfloat c = cos(a);
  GLfloat s = sin(a);

  array[ 0] = c;    array[ 1] = 0.0f; array[ 2] = -s;   array[ 3] = 0.0f;
  array[ 4] = 0.0f; array[ 5] = 1.0f; array[ 6] = 0.0f; array[ 7] = 0.0f;
  array[ 8] = s;    array[ 9] = 0.0f; array[10] = c;    array[11] = 0.0f;
  array[12] = 0.0f; array[13] = 0.0f; array[14] = 0.0f; array[15] = 1.0f;

  return *this;
}

/*
** 変換行列：z 軸中心の回転変換行列を設定する
*/
gg::GgMatrix &gg::GgMatrix::loadRotateZ(GLfloat a)
{
  GLfloat c = cos(a);
  GLfloat s = sin(a);

  array[ 0] = c;    array[ 1] = s;    array[ 2] = 0.0f; array[ 3] = 0.0f;
  array[ 4] = -s;   array[ 5] = c;    array[ 6] = 0.0f; array[ 7] = 0.0f;
  array[ 8] = 0.0f; array[ 9] = 0.0f; array[10] = 1.0f; array[11] = 0.0f;
  array[12] = 0.0f; array[13] = 0.0f; array[14] = 0.0f; array[15] = 1.0f;

  return *this;
}

/*
** 変換行列：任意軸中心の回転変換行列を設定する
*/
gg::GgMatrix &gg::GgMatrix::loadRotate(GLfloat x, GLfloat y, GLfloat z, GLfloat a)
{
  GLfloat d = sqrt(x * x + y * y + z * z);

  if (d > 0.0f)
  {
    GLfloat l  = x / d, m  = y / d, n  = z / d;
    GLfloat l2 = l * l, m2 = m * m, n2 = n * n;
    GLfloat lm = l * m, mn = m * n, nl = n * l;
    GLfloat c = cos(a), c1 = 1.0f - c;
    GLfloat s = sin(a);

    array[ 0] = (1.0f - l2) * c + l2;
    array[ 1] = lm * c1 + n * s;
    array[ 2] = nl * c1 - m * s;
    array[ 3] = 0.0f;

    array[ 4] = lm * c1 - n * s;
    array[ 5] = (1.0f - m2) * c + m2;
    array[ 6] = mn * c1 + l * s;
    array[ 7] = 0.0f;

    array[ 8] = nl * c1 + m * s;
    array[ 9] = mn * c1 - l * s;
    array[10] = (1.0f - n2) * c + n2;
    array[11] = 0.0f;

    array[12] = 0.0f;
    array[13] = 0.0f;
    array[14] = 0.0f;
    array[15] = 1.0f;
  }

  return *this;
}

/*
** 変換行列：転置行列を設定する
*/
gg::GgMatrix &gg::GgMatrix::loadTranspose(const GgMatrix &m)
{
  array[ 0] = m.array[ 0];
  array[ 1] = m.array[ 4];
  array[ 2] = m.array[ 8];
  array[ 3] = m.array[12];
  array[ 4] = m.array[ 1];
  array[ 5] = m.array[ 5];
  array[ 6] = m.array[ 9];
  array[ 7] = m.array[13];
  array[ 8] = m.array[ 2];
  array[ 9] = m.array[ 6];
  array[10] = m.array[10];
  array[11] = m.array[14];
  array[12] = m.array[ 3];
  array[13] = m.array[ 7];
  array[14] = m.array[11];
  array[15] = m.array[15];

  return *this;
}

/*
** 変換行列：逆行列を設定する
*/
gg::GgMatrix &gg::GgMatrix::loadInvert(const GgMatrix &m)
{
  GLfloat lu[20], *plu[4];
  const GLfloat *marray = m.array;

  // j 行の要素の値の絶対値の最大値を plu[j][4] に求める
  for (int j = 0; j < 4; ++j)
  {
    GLfloat max = fabs(*(plu[j] = lu + 5 * j) = *(marray++));

    for (int i = 0; ++i < 4;)
    {
      GLfloat a = fabs(plu[j][i] = *(marray++));
      if (a > max) max = a;
    }
    if (max == 0.0f) return *this;
    plu[j][4] = 1.0f / max;
  }

  // ピボットを考慮した LU 分解
  for (int j = 0; j < 4; ++j)
  {
    GLfloat max = fabs(plu[j][j] * plu[j][4]);
    int i = j;

    for (int k = j; ++k < 4;)
    {
      GLfloat a = fabs(plu[k][j] * plu[k][4]);
      if (a > max)
      {
        max = a;
        i = k;
      }
    }
    if (i > j)
    {
      GLfloat *t = plu[j];
      plu[j] = plu[i];
      plu[i] = t;
    }
    if (plu[j][j] == 0.0f) return *this;
    for (int k = j; ++k < 4;)
    {
      plu[k][j] /= plu[j][j];
      for (int i = j; ++i < 4;)
      {
        plu[k][i] -= plu[j][i] * plu[k][j];
      }
    }
  }

  // LU 分解から逆行列を求める
  for (int k = 0; k < 4; ++k)
  {
    // array に単位行列を設定する
    for (int i = 0; i < 4; ++i)
    {
      array[i * 4 + k] = (plu[i] == lu + k * 5) ? 1.0f : 0.0f;
    }
    // lu から逆行列を求める
    for (int i = 0; i < 4; ++i)
    {
      for (int j = i; ++j < 4;)
      {
        array[j * 4 + k] -= array[i * 4 + k] * plu[j][i];
      }
    }
    for (int i = 4; --i >= 0;)
    {
      for (int j = i; ++j < 4;)
      {
        array[i * 4 + k] -= plu[i][j] * array[j * 4 + k];
      }
      array[i * 4 + k] /= plu[i][i];
    }
  }

  return *this;
}

/*
** 変換行列：法線変換行列を設定する
*/
gg::GgMatrix &gg::GgMatrix::loadNormal(const GgMatrix &m)
{
  array[ 0] = m.array[ 5] * m.array[10] - m.array[ 6] * m.array[ 9];
  array[ 1] = m.array[ 6] * m.array[ 8] - m.array[ 4] * m.array[10];
  array[ 2] = m.array[ 4] * m.array[ 9] - m.array[ 5] * m.array[ 8];
  array[ 4] = m.array[ 9] * m.array[ 2] - m.array[10] * m.array[ 1];
  array[ 5] = m.array[10] * m.array[ 0] - m.array[ 8] * m.array[ 2];
  array[ 6] = m.array[ 8] * m.array[ 1] - m.array[ 9] * m.array[ 0];
  array[ 8] = m.array[ 1] * m.array[ 6] - m.array[ 2] * m.array[ 5];
  array[ 9] = m.array[ 2] * m.array[ 4] - m.array[ 0] * m.array[ 6];
  array[10] = m.array[ 0] * m.array[ 5] - m.array[ 1] * m.array[ 4];
  array[ 3] = array[ 7] = array[11] = array[12] = array[13] = array[14] = 0.0f;
  array[15] = 1.0f;

  return *this;
}

/*
** 変換行列：視野変換行列を設定する
*/
gg::GgMatrix &gg::GgMatrix::loadLookat(GLfloat ex, GLfloat ey, GLfloat ez, GLfloat tx, GLfloat ty, GLfloat tz, GLfloat ux, GLfloat uy, GLfloat uz)
{
  GLfloat l;

  // z 軸 = e - t
  tx = ex - tx;
  ty = ey - ty;
  tz = ez - tz;
  l = sqrt(tx * tx + ty * ty + tz * tz);
  if (l == 0.0f) return *this;
  array[ 2] = tx / l;
  array[ 6] = ty / l;
  array[10] = tz / l;

  // x 軸 = u x z 軸
  tx = uy * array[10] - uz * array[ 6];
  ty = uz * array[ 2] - ux * array[10];
  tz = ux * array[ 6] - uy * array[ 2];
  l = sqrt(tx * tx + ty * ty + tz * tz);
  if (l == 0.0f) return *this;
  array[ 0] = tx / l;
  array[ 4] = ty / l;
  array[ 8] = tz / l;

  // y 軸 = z 軸 x x 軸
  array[ 1] = array[ 6] * array[ 8] - array[10] * array[ 4];
  array[ 5] = array[10] * array[ 0] - array[ 2] * array[ 8];
  array[ 9] = array[ 2] * array[ 4] - array[ 6] * array[ 0];

  // 平行移動
  array[12] = -(ex * array[ 0] + ey * array[ 4] + ez * array[ 8]);
  array[13] = -(ex * array[ 1] + ey * array[ 5] + ez * array[ 9]);
  array[14] = -(ex * array[ 2] + ey * array[ 6] + ez * array[10]);

  // 残り
  array[ 3] = array[ 7] = array[11] = 0.0f;
  array[15] = 1.0f;

  return *this;
}

/*
** 変換行列：平行投影変換行列を設定する
*/
gg::GgMatrix &gg::GgMatrix::loadOrthogonal(GLfloat left, GLfloat right, GLfloat bottom, GLfloat top, GLfloat zNear, GLfloat zFar)
{
  GLfloat dx = right - left;
  GLfloat dy = top - bottom;
  GLfloat dz = zFar - zNear;

  if (dx != 0.0f && dy != 0.0f && dz != 0.0f)
  {
    array[ 0] =  2.0f / dx;
    array[ 5] =  2.0f / dy;
    array[10] = -2.0f / dz;
    array[12] = -(right + left) / dx;
    array[13] = -(top + bottom) / dy;
    array[14] = -(zFar + zNear) / dz;
    array[15] =  1.0f;
    array[ 1] = array[ 2] = array[ 3] = array[ 4] =
    array[ 6] = array[ 7] = array[ 8] = array[ 9] = array[11] = 0.0f;
  }

  return *this;
}

/*
** 変換行列：透視投影変換行列を設定する
*/
gg::GgMatrix &gg::GgMatrix::loadFrustum(GLfloat left, GLfloat right, GLfloat bottom, GLfloat top, GLfloat zNear, GLfloat zFar)
{
  GLfloat dx = right - left;
  GLfloat dy = top - bottom;
  GLfloat dz = zFar - zNear;

  if (dx != 0.0f && dy != 0.0f && dz != 0.0f)
  {
    array[ 0] =  2.0f * zNear / dx;
    array[ 5] =  2.0f * zNear / dy;
    array[ 8] =  (right + left) / dx;
    array[ 9] =  (top + bottom) / dy;
    array[10] = -(zFar + zNear) / dz;
    array[11] = -1.0f;
    array[14] = -2.0f * zFar * zNear / dz;
    array[ 1] = array[ 2] = array[ 3] = array[ 4] =
    array[ 6] = array[ 7] = array[12] = array[13] = array[15] = 0.0f;
  }

  return *this;
}

/*
** 変換行列：画角から透視投影変換行列を設定する
*/
gg::GgMatrix &gg::GgMatrix::loadPerspective(GLfloat fovy, GLfloat aspect, GLfloat zNear, GLfloat zFar)
{
  GLfloat dz = zFar - zNear;

  if (dz != 0.0f)
  {
    GLfloat f = 1.0f / tan(fovy * 0.5f);

    array[ 0] = f / aspect;
    array[ 5] = f;
    array[10] = -(zFar + zNear) / dz;
    array[11] = -1.0f;
    array[14] = -2.0f * zFar * zNear / dz;
    array[ 1] = array[ 2] = array[ 3] = array[ 4] =
    array[ 6] = array[ 7] = array[ 8] = array[ 9] =
    array[12] = array[13] = array[15] = 0.0f;
  }

  return *this;
}

/*
** 変換行列：視野変換行列を乗じる（視点の移動）
*/
gg::GgMatrix &gg::GgMatrix::lookat(GLfloat ex, GLfloat ey, GLfloat ez, GLfloat tx, GLfloat ty, GLfloat tz, GLfloat ux, GLfloat uy, GLfloat uz)
{
  GgMatrix m;

  m.loadLookat(ex, ey, ez, tx, ty, tz, ux, uy, uz);
  multiply(m);

  return *this;
}

/*
** 変換行列：平行投影変換行列を乗じる
*/
gg::GgMatrix &gg::GgMatrix::orthogonal(GLfloat left, GLfloat right, GLfloat bottom, GLfloat top, GLfloat zNear, GLfloat zFar)
{
  GgMatrix m;

  m.loadOrthogonal(left, right, bottom, top, zNear, zFar);
  multiply(m);

  return *this;
}

/*
** 変換行列：透視投影変換行列を乗じる
*/
gg::GgMatrix &gg::GgMatrix::frustum(GLfloat left, GLfloat right, GLfloat bottom, GLfloat top, GLfloat zNear, GLfloat zFar)
{
  GgMatrix m;

  m.loadFrustum(left, right, bottom, top, zNear, zFar);
  multiply(m);

  return *this;
}

/*
** 変換行列：画角から求めた透視投影変換行列を乗じる
*/
gg::GgMatrix &gg::GgMatrix::perspective(GLfloat fovy, GLfloat aspect, GLfloat zNear, GLfloat zFar)
{
  GgMatrix m;

  m.loadPerspective(fovy, aspect, zNear, zFar);
  multiply(m);

  return *this;
}

/*
** 四元数：四元数 p, q の和を r に求める
*/
void gg::GgQuaternion::add(GLfloat *r, const GLfloat *p, const GLfloat *q) const
{
  r[0] = p[0] + q[0];
  r[1] = p[1] + q[1];
  r[2] = p[2] + q[2];
  r[3] = p[3] + q[3];
}

/*
** 四元数：四元数 p, q の差を r に求める
*/
void gg::GgQuaternion::subtract(GLfloat *r, const GLfloat *p, const GLfloat *q) const
{
  r[0] = p[0] - q[0];
  r[1] = p[1] - q[1];
  r[2] = p[2] - q[2];
  r[3] = p[3] - q[3];
}

/*
** 四元数：四元数 p, q の積を r に求める
*/
void gg::GgQuaternion::multiply(GLfloat *r, const GLfloat *p, const GLfloat *q) const
{
  r[0] = p[1] * q[2] - p[2] * q[1] + p[0] * q[3] + p[3] * q[0];
  r[1] = p[2] * q[0] - p[0] * q[2] + p[1] * q[3] + p[3] * q[1];
  r[2] = p[0] * q[1] - p[1] * q[0] + p[2] * q[3] + p[3] * q[2];
  r[3] = p[3] * q[3] - p[0] * q[0] - p[1] * q[1] - p[2] * q[2];
}

/*
** 四元数：四元数 q が表す変換行列を m に求める
*/
void gg::GgQuaternion::toMatrix(GLfloat *m, const GLfloat *q) const
{
  GLfloat xx = q[0] * q[0] * 2.0f;
  GLfloat yy = q[1] * q[1] * 2.0f;
  GLfloat zz = q[2] * q[2] * 2.0f;
  GLfloat xy = q[0] * q[1] * 2.0f;
  GLfloat yz = q[1] * q[2] * 2.0f;
  GLfloat zx = q[2] * q[0] * 2.0f;
  GLfloat xw = q[0] * q[3] * 2.0f;
  GLfloat yw = q[1] * q[3] * 2.0f;
  GLfloat zw = q[2] * q[3] * 2.0f;

  m[ 0] = 1.0f - yy - zz;
  m[ 1] = xy + zw;
  m[ 2] = zx - yw;
  m[ 4] = xy - zw;
  m[ 5] = 1.0f - zz - xx;
  m[ 6] = yz + xw;
  m[ 8] = zx + yw;
  m[ 9] = yz - xw;
  m[10] = 1.0f - xx - yy;
  m[ 3] = m[ 7] = m[11] = m[12] = m[13] = m[14] = 0.0f;
  m[15] = 1.0f;
}

/*
** 四元数：回転変換行列 m が表す四元数を q に求める
*/
void gg::GgQuaternion::toQuaternion(GLfloat *q, const GLfloat *m) const
{
  GLfloat tr = m[0] + m[5] + m[10] + m[15];

  if (tr > 0.0f)
  {
    q[3] = sqrt(tr) * 0.5f;
    q[0] = (m[6] - m[9]) * 0.25f / q[3];
    q[1] = (m[8] - m[2]) * 0.25f / q[3];
    q[2] = (m[1] - m[4]) * 0.25f / q[3];
  }
}

/*
** 四元数：球面線形補間 p に q と r を t で補間した四元数を求める
*/
void gg::GgQuaternion::slerp(GLfloat *p, const GLfloat *q, const GLfloat *r, GLfloat t) const
{
  GLfloat qr = q[0] * r[0] + q[1] * r[1] + q[2] * r[2] + q[3] * r[3];
  GLfloat ss = 1.0f - qr * qr;

  if (ss == 0.0f)
  {
    if (p != q)
    {
      p[0] = q[0];
      p[1] = q[1];
      p[2] = q[2];
      p[3] = q[3];
    }
  }
  else
  {
    GLfloat sp = sqrt(ss);
    GLfloat ph = acos(qr);
    GLfloat pt = ph * t;
    GLfloat t1 = sin(pt) / sp;
    GLfloat t0 = sin(ph - pt) / sp;

    p[0] = q[0] * t0 + r[0] * t1;
    p[1] = q[1] * t0 + r[1] * t1;
    p[2] = q[2] * t0 + r[2] * t1;
    p[3] = q[3] * t0 + r[3] * t1;
  }
}

/*
** 四元数：(x, y, z) を軸とし角度 a 回転する四元数を求める
*/
gg::GgQuaternion &gg::GgQuaternion::loadRotate(GLfloat x, GLfloat y, GLfloat z, GLfloat a)
{
  GLfloat l = x * x + y * y + z * z;

  if (l != 0.0)
  {
    GLfloat s = sin(a *= 0.5f) / sqrt(l);

    array[0] = x * s;
    array[1] = y * s;
    array[2] = z * s;
  }
  else
  {
    array[0] = array[1] = array[2] = 0.0f;
  }
  array[3] = cos(a);

  return *this;
}

/*
** 四元数：オイラー角 (h, p, r) にもとづいて四元数を求める
*/
gg::GgQuaternion &gg::GgQuaternion::loadEuler(GLfloat h, GLfloat p, GLfloat r)
{
  return loadRotate(-sin(h) * cos(p), sin(p), cos(h) * cos(p), r);
}

/*
** 四元数：ノルム
*/
GLfloat gg::GgQuaternion::norm(void) const
{
  return sqrt(array[0] * array[0] + array[1] * array[1] + array[2] * array[2] + array[3] * array[3]);
}

/*
** 四元数：四元数 q の共役を r に求める
*/
gg::GgQuaternion gg::GgQuaternion::conjugate(void) const
{
  GgQuaternion t(-array[0], -array[1], -array[2], array[3]);

  return t;
}

/*
** 四元数：四元数 q の逆を r に求める
*/
gg::GgQuaternion gg::GgQuaternion::invert(void) const
{
  GgQuaternion t = conjugate();
  GLfloat l = array[0] * array[0] + array[1] * array[1] + array[2] * array[2] + array[3] * array[3];

  if (l > 0.0f)
  {
    t.array[0] /= l;
    t.array[1] /= l;
    t.array[2] /= l;
    t.array[3] /= l;
  }

  return t;
}

/*
** 四元数：正規化
*/
gg::GgQuaternion gg::GgQuaternion::normalize(void) const
{
  GgQuaternion t = *this;
  GLfloat l = norm();

  if (l > 0.0f)
  {
    t.array[0] /= l;
    t.array[1] /= l;
    t.array[2] /= l;
    t.array[3] /= l;
  }

  return t;
}

/*
** 簡易トラックボール処理：コンストラクタ
*/
gg::GgTrackball::GgTrackball(void)
{
  // ドラッグ中ではない
  drag = false;

  // 単位クォーターニオン
  cq.loadIdentity();

  // 回転行列の初期化
  cq.getMatrix(rt);
}

/*
** 簡易トラックボール処理：トラックボールする領域の設定
**
**    Reshape コールバック (resize) の中で実行する
**    (w, h): ウィンドウサイズ
*/
void gg::GgTrackball::region(int w, int h)
{
  // マウスポインタ位置のウィンドウ内の相対的位置への換算用
  sx = 1.0f / static_cast<float>(w);
  sy = 1.0f / static_cast<float>(h);
}

/*
** 簡易トラックボール処理：ドラッグ開始時の処理
**
**    マウスボタンを押したときに実行する
**    (x, y): 現在のマウス位置
*/
void gg::GgTrackball::start(int x, int y)
{
  // ドラッグ開始
  drag = true;

  // ドラッグ開始点を記録する
  cx = x;
  cy = y;
}

/*
** 簡易トラックボール処理：ドラッグ中の処理
**
**    マウスのドラッグ中に実行する
**    (x, y): 現在のマウス位置
*/
void gg::GgTrackball::motion(int x, int y)
{
  if (drag)
  {
    float dx, dy, a;

    // マウスポインタの位置のドラッグ開始位置からの変位
    dx = (x - cx) * sx;
    dy = (y - cy) * sy;

    // マウスポインタの位置のドラッグ開始位置からの距離
    a = sqrt(dx * dx + dy * dy);

    if (a != 0.0)
    {
      // 回転軸と回転角から四元数を作る
      GgQuaternion dq;
      dq.loadRotate(dy, dx, 0.0f, a * 6.283185f);

      // 現在の回転の四元数に作った四元数を掛けて合成する
      tq = dq * cq;

      // 合成した四元数から回転の変換行列を求める
      tq.getMatrix(rt);
    }
  }
}

/*
** 簡易トラックボール処理：停止時の処理
**
**    マウスボタンを離したときに実行する
**    (x, y): 現在のマウス位置
*/
void gg::GgTrackball::stop(int x, int y)
{
  // ドラッグ終了点における回転を求める
  motion(x, y);

  // 現在の回転を表す四元数を正規化して保存する
  cq = tq.normalize();

  // ドラッグ終了
  drag = false;
}

/*
** ポイント：描画
*/
void gg::GgPoints::draw(void) const
{
  // シェーダプログラムの使用を開始する
  getShader()->use(pbuf());

  // 図形を描画する
  glDrawArrays(mode, 0, pnum());

  // シェーダプログラムの使用を終了する
  getShader()->unuse();
}

/*
** ポリゴン：描画
*/
void gg::GgTriangles::draw(void) const
{
  // シェーダプログラムの使用を開始する
  getShader()->use(pbuf(), nbuf());

  // 図形を描画する
  glDrawArrays(mode, 0, pnum());

  // シェーダプログラムの使用を終了する
  getShader()->unuse();
}

/*
** オブジェクト：描画
*/
void gg::GgElements::draw(void) const
{
  // シェーダプログラムの使用を開始する
  getShader()->use(pbuf(), nbuf());

  // インデックスにバッファオブジェクトを指定する
  glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, fbuf());

  // 図形を描画する
  glDrawElements(mode, fnum() * 3, GL_UNSIGNED_INT, 0);

  // バッファオブジェクトの指定を解除する
  glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, 0);

  // シェーダプログラムの使用を終了する
  getShader()->unuse();
}

/*
** 球状のポイント
*/
gg::GgPoints *gg::ggPointSphere(GLuint nv, GLfloat cx, GLfloat cy, GLfloat cz, GLfloat radius)
{
  // メモリの確保
  GLfloat (*vert)[3] = new GLfloat[nv][3];

  // 点の生成
  for (GLuint v = 0; v < nv; ++v)
  {
    float r = radius * static_cast<float>(rand()) / static_cast<float>(RAND_MAX);
    float t = 6.2831853f * static_cast<float>(rand()) / (static_cast<float>(RAND_MAX) + 1.0f);
    float cp = 2.0f * static_cast<float>(rand()) / static_cast<float>(RAND_MAX) - 1.0f;
    float sp = sqrt(1.0f - cp * cp);
    float ct = cos(t), st = sin(t);

    vert[v][0] = r * sp * ct + cx;
    vert[v][1] = r * sp * st + cy;
    vert[v][2] = r * cp + cz;
  }

  // ポイントの作成
  GgPoints *points = new gg::GgPoints(nv, vert);

  // 作業用のメモリの解放
  delete[] vert;

  return points;
}

/*
** 矩形
*/
gg::GgTriangles *gg::ggRectangle(GLfloat width, GLfloat height)
{
  // 基準となる形状
  static const GLfloat p[][2] =
  {
    { -0.5f, -0.5f },
    {  0.5f, -0.5f },
    {  0.5f,  0.5f },
    { -0.5f,  0.5f },
  };

  // メモリの確保
  GLfloat vert[4][3];
  GLfloat norm[4][3];

  // 頂点位置の計算
  for (int v = 0; v < 4; ++v)
  {
    vert[v][0] = p[v][0] * width;
    vert[v][1] = p[v][1] * height;
    vert[v][2] = 0.0f;

    norm[v][0] = 0.0f;
    norm[v][1] = 0.0f;
    norm[v][2] = 1.0f;
  }

  // ポリゴンの作成
  GgTriangles *rectangle = new gg::GgTriangles(4, vert, norm);
  rectangle->setMode(GL_TRIANGLE_FAN);

  return rectangle;
}

/*
** 楕円
*/
gg::GgTriangles *gg::ggEllipse(GLfloat width, GLfloat height, GLuint slices)
{
  // メモリの確保
  GLfloat (*vert)[3] = 0;
  GLfloat (*norm)[3] = 0;
  try
  {
    vert = new GLfloat[slices][3];
    norm = new GLfloat[slices][3];
  }
  catch (std::bad_alloc e)
  {
    delete[] vert;
    delete[] norm;
    throw e;
  }

  // 頂点位置の計算
  for (GLuint v = 0; v < slices; ++v)
  {
    float t = 6.2831853f * static_cast<float>(v) / static_cast<float>(slices);

    vert[v][0] = cos(t) * width * 0.5f;
    vert[v][1] = sin(t) * height * 0.5f;
    vert[v][2] = 0.0f;

    norm[v][0] = 0.0f;
    norm[v][1] = 0.0f;
    norm[v][2] = 1.0f;
  } 

  // ポリゴンの作成
  GgTriangles *ellipse = new gg::GgTriangles(slices, vert, norm);
  ellipse->setMode(GL_TRIANGLE_FAN);

  // 作業用のメモリの解放
  delete[] vert;
  delete[] norm;

  return ellipse;
}

/*
** 三角形分割された Alias OBJ ファイル (Arrays 形式)
*/
gg::GgTriangles *gg::ggArraysObj(const char *name, bool normalize)
{
  GLuint ng, nv;
  GLuint (*group)[2];
  GLfloat (*ka)[4], (*kd)[4], (*ks)[4], *kshi;
  GLfloat (*vert)[3], (*norm)[3];

  if (!ggLoadObj(name, ng, group, ka, kd, ks, kshi, nv, vert, norm, normalize)) return 0;

  // オブジェクトの作成
  GgTriangles *obj = new gg::GgTriangles(nv, vert, norm);

  // 作業用のメモリの解放
  delete[] group;
  delete[] ka;
  delete[] kd;
  delete[] ks;
  delete[] kshi;
  delete[] vert;
  delete[] norm;

  return obj;
}

/*
** 三角形分割された Alias OBJ ファイル (Elements 形式)
*/
gg::GgElements *gg::ggElementsObj(const char *name, bool normalize)
{
  GLuint nv, nf;
  GLfloat (*vert)[3], (*norm)[3];
  GLuint (*face)[3];

  if (!ggLoadObj(name, nv, vert, norm, nf, face, normalize)) return 0;

  // オブジェクトの作成
  GgElements *obj = new gg::GgElements(nv, vert, norm, nf, face);

  // 作業用のメモリの解放
  delete[] vert;
  delete[] norm;
  delete[] face;

  return obj;
}
